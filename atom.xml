<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coderbxd的博客</title>
  
  <subtitle>重庆移通学院 2022 软件工程</subtitle>
  <link href="http://coderbxd.top/atom.xml" rel="self"/>
  
  <link href="http://coderbxd.top/"/>
  <updated>2021-07-04T08:16:11.989Z</updated>
  <id>http://coderbxd.top/</id>
  
  <author>
    <name>bxd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么会出现浮动？浮动元素会引起什么问题？如何清除浮动？</title>
    <link href="http://coderbxd.top/2021/07/04/css08-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%B5%AE%E5%8A%A8/"/>
    <id>http://coderbxd.top/2021/07/04/css08-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%B5%AE%E5%8A%A8/</id>
    <published>2021-07-04T08:04:06.690Z</published>
    <updated>2021-07-04T08:16:11.989Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浮动定位将元素排除在普通流之外，即元素讲脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留"><a href="#浮动定位将元素排除在普通流之外，即元素讲脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留" class="headerlink" title="浮动定位将元素排除在普通流之外，即元素讲脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留"></a>浮动定位将元素排除在普通流之外，即元素讲脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留</h3><h3 id="为什么需要清除浮动"><a href="#为什么需要清除浮动" class="headerlink" title="为什么需要清除浮动"></a>为什么需要清除浮动</h3><ul><li><p>父元素的高度无法被撑开，影响与父元素同级的元素</p></li><li><p>与浮动元素同级的非浮动元素（内联元素）会跟随其后</p></li><li><p>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解<br>决方法</p></li></ul><h3 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h3><ul><li><p>使用 CSS 中的 clear:both;（放一个空的 div，并设置上述 css）,属性来清除元素的浮动<br>可解决 2、3 问题</p></li><li><p>对于问题 1，添加如下样式，给父元素添加 clearfix 样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .clearfix:after &#123;</span><br><span class="line"><span class="css">    <span class="attribute">content</span>: <span class="string">&quot;.&quot;</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="css">    <span class="attribute">visibility</span>: hidden;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .clearfix &#123;</span><br><span class="line"><span class="css">    <span class="attribute">display</span>: inline-block;</span></span><br><span class="line">  &#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>给父级元素设置双伪元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container clearfix&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .clearfix:after&#123;</span><br><span class="line"><span class="css">    <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>; <span class="comment">/*设置内容为空*/</span></span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>:<span class="number">0</span>; <span class="comment">/*高度为 0*/</span></span></span><br><span class="line"><span class="css">    <span class="attribute">line-height</span>:<span class="number">0</span>; <span class="comment">/*行高为 0*/</span></span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>:block; <span class="comment">/*将文本转为块级元素*/</span></span></span><br><span class="line"><span class="css">    <span class="attribute">visibility</span>:hidden; <span class="comment">/*将元素隐藏*/</span></span></span><br><span class="line"><span class="css">    <span class="attribute">clear</span>:both; <span class="comment">/*清除浮动*/</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  .clearfix&#123;</span><br><span class="line"><span class="css">    zoom:<span class="number">1</span>; <span class="comment">/*为了兼容 IE*/</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>给父级元素设置 overflow：hidden；或 overflow：auto；本质是构建一个 BFC</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;浮动定位将元素排除在普通流之外，即元素讲脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留&quot;&gt;&lt;a href=&quot;#浮动定位将元素排除在普通流之外，即元素讲脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留&quot; class=&quot;h</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>rem布局如何计算HTML根字号及适配方案？</title>
    <link href="http://coderbxd.top/2021/07/04/css07-rem%E5%B8%83%E5%B1%80%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%9A%84/"/>
    <id>http://coderbxd.top/2021/07/04/css07-rem%E5%B8%83%E5%B1%80%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E7%9A%84/</id>
    <published>2021-07-04T07:46:07.342Z</published>
    <updated>2021-07-04T08:17:06.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id="通用方案"><a href="#通用方案" class="headerlink" title="通用方案"></a>通用方案</h3><ul><li><p>设置根 font-size：625%（或其它自定的值，但换算规则 1rem 不能小于 12px）</p></li><li><p>通过媒体查询分别设置每个屏幕的根 font-size</p></li><li><p>CSS 直接除以 2 再除以 100 即可换算为 rem</p></li></ul><p>优：有一定适用性，换算也较为简单</p><p>劣：有兼容性的坑，对不同手机适配不是非常精准；需要设置多个媒体查询来适应不同<br>手机，单某款手机尺寸不在设置范围之内，会导致无法适配</p><h3 id="网易方案"><a href="#网易方案" class="headerlink" title="网易方案"></a>网易方案</h3><ul><li><p>拿到设计稿除以 100，得到宽度 rem 值</p></li><li><p>通过给 html 的 style 设置 font-size，把 1 里面得到的宽度 rem 值代入</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  x <span class="built_in">document</span>.documentElement.style.fontSize =</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.documentElement.clientWidth / x + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>设计稿 px/100 即可换算为 rem</li></ul><p>优：通过动态根 font-size 来做适配，基本无兼容性问题，适配较为精准，换算简便</p><p>劣：无 viewport 缩放，且针对 iPhone 的 Retina 屏没有做适配，导致对一些手机的适<br>配不是很到位</p><h3 id="手淘方案"><a href="#手淘方案" class="headerlink" title="手淘方案"></a>手淘方案</h3><ul><li><p>拿到设计稿除以 10，得到 font-size 基准值</p></li><li><p>引入 flexible</p></li><li><p>不要设置 meta 的 viewport 缩放值</p></li><li><p>设计稿 px/ font-size 基准值，即可换算为 rem</p></li></ul><p>优：通过动态根 font-size、viewpor、dpr 来做适配，无兼容性问题，适配精准。</p><p>劣：需要根据设计稿进行基准值换算，在不使用 sublime text 编辑器插件开发时，单<br>位计算复杂</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;通用方案&quot;&gt;&lt;a href=&quot;#通用方案&quot; class=&quot;headerlink&quot; title=&quot;通用方案&quot;&gt;&lt;/a&gt;通用方案&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置根 font-size：625%（或其它自定的值，但换算规则 1rem 不能小于 12px）&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>px,em,rem的区别</title>
    <link href="http://coderbxd.top/2021/07/03/css06-px,em,rem%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://coderbxd.top/2021/07/03/css06-px,em,rem%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-03T09:01:07.125Z</published>
    <updated>2021-07-03T09:23:03.601Z</updated>
    
    <content type="html"><![CDATA[<h3 id="px-em-rem的区别"><a href="#px-em-rem的区别" class="headerlink" title="px,em,rem的区别"></a>px,em,rem的区别</h3><ul><li><p>px </p><ul><li>px 像素 绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一<br>个虚拟长度单位，是计算机系统的数字化图像长度单位</li></ul></li><li><p>em </p><ul><li>em是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字<br>体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大<br>小，因此并不是一个固定的值</li></ul></li><li><p>rem </p><ul><li>rem是CSS3 新增的一个相对单位（root em，根 em），使用 rem 为元素设定字<br>体大小时，仍然是相对大小，但相对的只是 HTML 根元素</li></ul></li><li><p>区别<br>IE 无法调整那些使用 px 作为单位的字体大小，而 em 和 rem 可以缩放，rem<br>相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通<br>过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐<br>层复合的连锁反应。目前，除了 IE8 及更早版本外，所有浏览器均已支持rem</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;px-em-rem的区别&quot;&gt;&lt;a href=&quot;#px-em-rem的区别&quot; class=&quot;headerlink&quot; title=&quot;px,em,rem的区别&quot;&gt;&lt;/a&gt;px,em,rem的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;px &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;px 像</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css中那些属性可继承，哪些不可以？</title>
    <link href="http://coderbxd.top/2021/07/03/css05-%E5%8F%AF%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
    <id>http://coderbxd.top/2021/07/03/css05-%E5%8F%AF%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7/</id>
    <published>2021-07-03T08:49:09.605Z</published>
    <updated>2021-07-03T09:00:46.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="能继承的属性"><a href="#能继承的属性" class="headerlink" title="能继承的属性"></a>能继承的属性</h3><ul><li>字体系列属性<ul><li>font</li></ul></li><li>文本系列属性<ul><li>内联元素：color, line-height, word-spacing, letter-spacing, text-transform</li><li>块级元素：text-indent, text-align</li></ul></li><li>元素可见性<ul><li>visiblity</li></ul></li><li>表格布局属性<ul><li>caption-side, border-collapse, border-spacing, empty-cells, table-layout</li></ul></li><li>列表布局属性<ul><li>list-style</li></ul></li></ul><h3 id="不能继承的属性"><a href="#不能继承的属性" class="headerlink" title="不能继承的属性"></a>不能继承的属性</h3><ul><li>display<ul><li>规定元素应该生成的框的类型</li></ul></li><li>文本属性<ul><li>vertical-align, text-decoration</li></ul></li><li>盒子模型的模型<ul><li>width, height, margin, border, padding</li></ul></li><li>背景属性<ul><li>background, background-image, background-color</li></ul></li><li>定位属性<ul><li>float, clear, position, top, right, bottom, left, min-width, min-height<br>, max-width, max-height, overflow, clip</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;能继承的属性&quot;&gt;&lt;a href=&quot;#能继承的属性&quot; class=&quot;headerlink&quot; title=&quot;能继承的属性&quot;&gt;&lt;/a&gt;能继承的属性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;字体系列属性&lt;ul&gt;
&lt;li&gt;font&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文本系列属性&lt;</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>input元素type属性值</title>
    <link href="http://coderbxd.top/2021/07/03/html02-h5input%E5%85%83%E7%B4%A0type%E5%80%BC/"/>
    <id>http://coderbxd.top/2021/07/03/html02-h5input%E5%85%83%E7%B4%A0type%E5%80%BC/</id>
    <published>2021-07-03T08:14:35.843Z</published>
    <updated>2021-07-03T09:09:30.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="H5-input元素type属性值"><a href="#H5-input元素type属性值" class="headerlink" title="H5 input元素type属性值"></a>H5 input元素type属性值</h3><ul><li>button 按钮</li><li>checkout 复选框</li><li>color 颜色</li><li>date 定义日期字段</li><li>month 定义日期字段的月</li><li>time 日期字段的时、分、秒</li><li>email 定义用于 e-mail地址的文本字段</li><li>file 定义输入字段和”浏览…” 按钮，供文件上传</li><li>hidden 隐藏输入字段</li><li>image 定义图像作为提交按钮</li><li>number 定义带有 spinner 控件的数字字段</li><li>password 定义密码字段。字段中的字符会被遮蔽。</li><li>radio 定义单选按钮。</li><li>search 定义用于搜索的文本字段。</li><li>submit 定义提交按钮。提交按钮向服务器发送数据。</li><li>text 默认。定义单行输入字段，用户可在其中输入文本。默认是 20 个字符。</li><li>url 定义用于 URL 的文本字段。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;H5-input元素type属性值&quot;&gt;&lt;a href=&quot;#H5-input元素type属性值&quot; class=&quot;headerlink&quot; title=&quot;H5 input元素type属性值&quot;&gt;&lt;/a&gt;H5 input元素type属性值&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;butt</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="HTML" scheme="http://coderbxd.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>css选择器优先级</title>
    <link href="http://coderbxd.top/2021/07/03/css04-css%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://coderbxd.top/2021/07/03/css04-css%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7/</id>
    <published>2021-07-03T06:49:51.859Z</published>
    <updated>2021-07-03T08:15:18.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><ul><li>!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</li><li>权重 <ul><li>css权重是由四个数值决定</li><li>第一等：内联样式：style = “”, 权值1000 不推荐使用，不利于管理</li><li>第二等：ID选择器：#header，权值100</li><li>第三等： 类，伪类，属性选择器：.bar，权值10</li><li>第四等：标签，伪元素选择器：div::first-line，权值1</li><li>将所有值相加就是当前元素的权重</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;权重&quot;&gt;&lt;a href=&quot;#权重&quot; class=&quot;headerlink&quot; title=&quot;权重&quot;&gt;&lt;/a&gt;权重&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;!important &amp;gt; 行内样式 &amp;gt; ID选择器 &amp;gt; 类选择器 &amp;gt; 标签 &amp;gt; 通配符 &amp;gt; </summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css盒模型</title>
    <link href="http://coderbxd.top/2021/07/03/css03-%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <id>http://coderbxd.top/2021/07/03/css03-%E7%9B%92%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-07-03T06:30:49.724Z</published>
    <updated>2021-07-03T06:49:36.183Z</updated>
    
    <content type="html"><![CDATA[<h3 id="盒子模型可以用来对元素进行布局，包括内边距，边框，外边距和实际内容"><a href="#盒子模型可以用来对元素进行布局，包括内边距，边框，外边距和实际内容" class="headerlink" title="盒子模型可以用来对元素进行布局，包括内边距，边框，外边距和实际内容"></a>盒子模型可以用来对元素进行布局，包括内边距，边框，外边距和实际内容</h3><h3 id="盒子模型分为两种"><a href="#盒子模型分为两种" class="headerlink" title="盒子模型分为两种"></a>盒子模型分为两种</h3><ul><li>W3C 标准的盒子模型（标准盒模型）</li><li>IE 标准的盒子模型（怪异盒模型）</li></ul><h3 id="标准盒模型与怪异盒模型的表现效果的区别之处"><a href="#标准盒模型与怪异盒模型的表现效果的区别之处" class="headerlink" title="标准盒模型与怪异盒模型的表现效果的区别之处"></a>标准盒模型与怪异盒模型的表现效果的区别之处</h3><ul><li>标准盒模型的盒子大小 = content + border + padding + margin </li><li>怪异盒模型的盒子大小 = width(content + border + padding) + margin</li></ul><h3 id="可以通过属性box-sizing-来设置盒子模型的解析模式"><a href="#可以通过属性box-sizing-来设置盒子模型的解析模式" class="headerlink" title="可以通过属性box-sizing 来设置盒子模型的解析模式"></a>可以通过属性box-sizing 来设置盒子模型的解析模式</h3><ul><li>box-sizing: content-box; (默认值),border和padding不算在宽度内<br>是W3C的标准模型 总宽 = width + padding + border + margin</li><li>box-sizing: border-box; border和padding计算在宽度里，可以理解是怪异模型<br>总宽 = width + margin</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;盒子模型可以用来对元素进行布局，包括内边距，边框，外边距和实际内容&quot;&gt;&lt;a href=&quot;#盒子模型可以用来对元素进行布局，包括内边距，边框，外边距和实际内容&quot; class=&quot;headerlink&quot; title=&quot;盒子模型可以用来对元素进行布局，包括内边距，边框，外</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>三栏布局--双飞翼布局（圣杯布局）</title>
    <link href="http://coderbxd.top/2021/07/03/css02-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80(%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80)/"/>
    <id>http://coderbxd.top/2021/07/03/css02-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80(%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80)/</id>
    <published>2021-07-03T06:09:18.753Z</published>
    <updated>2021-07-03T06:30:35.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="利用定位实现两侧固定中间自适应"><a href="#利用定位实现两侧固定中间自适应" class="headerlink" title="利用定位实现两侧固定中间自适应"></a>利用定位实现两侧固定中间自适应</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.father &#123;</span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.left,.right &#123;</span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">350px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- html 结构 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用flex布局实现两侧固定中间自适应"><a href="#利用flex布局实现两侧固定中间自适应" class="headerlink" title="利用flex布局实现两侧固定中间自适应"></a>利用flex布局实现两侧固定中间自适应</h3><ul><li>父盒子设置display: flex;</li><li>左右盒子设置固定高度</li><li>中间盒子设置固定宽高</li><li>中间盒子设置flex: 1;</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.father &#123;</span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">  <span class="attribute">display</span>: flex;</span></span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line"><span class="css">  <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: blue;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用BFC块级格式化上下文，实现两侧固定中间自适应"><a href="#使用BFC块级格式化上下文，实现两侧固定中间自适应" class="headerlink" title="使用BFC块级格式化上下文，实现两侧固定中间自适应"></a>使用BFC块级格式化上下文，实现两侧固定中间自适应</h3><ul><li>左右固定宽高，进行浮动</li><li>中间 overflow: hidden;</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.father &#123;</span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: pink;</span></span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line"><span class="css">  <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: blue;</span></span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line"><span class="css">  <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: blue;</span></span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">450px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">  <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- html 结构 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- left和right必须在center前面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;利用定位实现两侧固定中间自适应&quot;&gt;&lt;a href=&quot;#利用定位实现两侧固定中间自适应&quot; class=&quot;headerlink&quot; title=&quot;利用定位实现两侧固定中间自适应&quot;&gt;&lt;/a&gt;利用定位实现两侧固定中间自适应&lt;/h3&gt;&lt;figure class=&quot;highli</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>如何实现盒子水平垂直居中</title>
    <link href="http://coderbxd.top/2021/07/03/css01-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <id>http://coderbxd.top/2021/07/03/css01-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</id>
    <published>2021-07-03T05:45:54.566Z</published>
    <updated>2021-07-03T06:05:10.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法一-利用定位"><a href="#方法一-利用定位" class="headerlink" title="方法一 利用定位"></a>方法一 利用定位</h3><ul><li>核心代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .parent &#123;</span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法二-利用margin-auto"><a href="#方法二-利用margin-auto" class="headerlink" title="方法二 利用margin:auto"></a>方法二 利用margin:auto</h3><ul><li>核心代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .parent &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法三-利用display-table-cell"><a href="#方法三-利用display-table-cell" class="headerlink" title="方法三 利用display: table-cell;"></a>方法三 利用display: table-cell;</h3><ul><li>核心代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .parent &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="css">    <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: inline-block</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法四-利用display-flex"><a href="#方法四-利用display-flex" class="headerlink" title="方法四 利用display: flex;"></a>方法四 利用display: flex;</h3><ul><li>核心代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .parent &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">    <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">align-items</span>: center;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法五-利用transform"><a href="#方法五-利用transform" class="headerlink" title="方法五 利用transform"></a>方法五 利用transform</h3><ul><li>核心代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .parent &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span></span><br><span class="line"><span class="css">    <span class="comment">/* 不用计算宽高 */</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;方法一-利用定位&quot;&gt;&lt;a href=&quot;#方法一-利用定位&quot; class=&quot;headerlink&quot; title=&quot;方法一 利用定位&quot;&gt;&lt;/a&gt;方法一 利用定位&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;核心代码&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器输入网址到页面渲染全过程</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A807-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A807-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%85%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2021-07-02T07:15:28.371Z</published>
    <updated>2021-07-02T07:16:41.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="输入URL到页面加载显示完成发生了什么"><a href="#输入URL到页面加载显示完成发生了什么" class="headerlink" title="输入URL到页面加载显示完成发生了什么"></a>输入URL到页面加载显示完成发生了什么</h3><ul><li><p>DNS解析</p></li><li><p>TCP连接</p></li><li><p>发送HTTP请求</p></li><li><p>服务器处理请求并返回HTTP报文</p></li><li><p>浏览器解析渲染页面</p></li><li><p>连接结束</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;输入URL到页面加载显示完成发生了什么&quot;&gt;&lt;a href=&quot;#输入URL到页面加载显示完成发生了什么&quot; class=&quot;headerlink&quot; title=&quot;输入URL到页面加载显示完成发生了什么&quot;&gt;&lt;/a&gt;输入URL到页面加载显示完成发生了什么&lt;/h3&gt;&lt;ul&gt;
</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>csrf和xss</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A806-xss%E5%92%8Ccsrf/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A806-xss%E5%92%8Ccsrf/</id>
    <published>2021-07-02T07:11:19.095Z</published>
    <updated>2021-07-02T07:14:34.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="csrf和xss的网络攻击及防范"><a href="#csrf和xss的网络攻击及防范" class="headerlink" title="csrf和xss的网络攻击及防范"></a>csrf和xss的网络攻击及防范</h3><ul><li><p>CSRF：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求，比如用户登录了一个网站后，立刻在另一个ｔａｂ页面访问量攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库</p><ul><li>防御CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</li></ul></li><li><p>XSS：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在url地址的请求参数中  </p><ul><li>防御xss cookie设置httpOnly属性，对用户的输入进行检查，进行特殊字符过滤</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;csrf和xss的网络攻击及防范&quot;&gt;&lt;a href=&quot;#csrf和xss的网络攻击及防范&quot; class=&quot;headerlink&quot; title=&quot;csrf和xss的网络攻击及防范&quot;&gt;&lt;/a&gt;csrf和xss的网络攻击及防范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CSRF：</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>HTML5新增属性</title>
    <link href="http://coderbxd.top/2021/07/02/html01-HTML5%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7/"/>
    <id>http://coderbxd.top/2021/07/02/html01-HTML5%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7/</id>
    <published>2021-07-02T07:07:43.079Z</published>
    <updated>2021-07-02T07:09:00.407Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML5新增元素"><a href="#HTML5新增元素" class="headerlink" title="HTML5新增元素"></a>HTML5新增元素</h3><ul><li><p>首先html5为了更好的实践web语义化，增加了header，footer，nav,aside,section等语义化标签</p></li><li><p>在表单方面，为了增强表单，为input增加了color，emial,data ,range等类型</p></li><li><p>在存储方面，提供了sessionStorage，localStorage,和离线存储，通过这些存储方式方便数据在客户端的存储和获取</p></li><li><p>在多媒体方面规定了音频和视频元素audio和vedio，另外还有地理定位，canvas画布，拖放，多线程编程的web worker和websocket协议</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HTML5新增元素&quot;&gt;&lt;a href=&quot;#HTML5新增元素&quot; class=&quot;headerlink&quot; title=&quot;HTML5新增元素&quot;&gt;&lt;/a&gt;HTML5新增元素&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先html5为了更好的实践web语义化，增加了header，fo</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="HTML" scheme="http://coderbxd.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>http2.0新特性</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A805-http2.0%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A805-http2.0%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-07-02T07:05:16.096Z</published>
    <updated>2021-07-02T07:06:45.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="http2-0的特性如下"><a href="#http2-0的特性如下" class="headerlink" title="http2.0的特性如下"></a>http2.0的特性如下</h3><ul><li><p>内容安全，应为http2.0是基于https的，天然具有安全特性，通过http2.0的特性可以避免单纯使用https的性能下降</p></li><li><p>二进制格式，http1.X的解析是基于文本的，http2.0将所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式编码，基于二进制可以让协议有更多的扩展性，比如引入了帧来传输数据和指令</p></li><li><p>多路复用，这个功能相当于是长连接的增强，每个request请求可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面，另外多路复用中也支持了流的优先级，允许客户端告诉服务器那些内容是更优先级的资源，可以优先传输，</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;http2-0的特性如下&quot;&gt;&lt;a href=&quot;#http2-0的特性如下&quot; class=&quot;headerlink&quot; title=&quot;http2.0的特性如下&quot;&gt;&lt;/a&gt;http2.0的特性如下&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;内容安全，应为http2.0是基于http</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>http返回的状态码</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A804-http%E8%BF%94%E5%9B%9E%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%97/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A804-http%E8%BF%94%E5%9B%9E%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%97/</id>
    <published>2021-07-02T06:50:44.955Z</published>
    <updated>2021-07-02T06:55:47.998Z</updated>
    
    <content type="html"><![CDATA[<h3 id="状态码大全"><a href="#状态码大全" class="headerlink" title="状态码大全"></a>状态码大全</h3><ul><li><p>100    Continue    继续。客户端应继续其请求</p></li><li><p>101    Switching Protocols    切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，+ 例如，切换到HTTP的新版本协议</p></li><li><p>200    OK    请求成功。一般用于GET与POST请求</p></li><li><p>201    Created    已创建。成功请求并创建了新的资源</p></li><li><p>202    Accepted    已接受。已经接受请求，但未处理完成</p></li><li><p>203    Non-Authoritative Information    非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</p></li><li><p>204    No Content    无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</p></li><li><p>205    Reset Content    重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单</p></li><li><p>206    Partial Content    部分内容。服务器成功处理了部分GET请求</p></li><li><p>300    Multiple Choices    多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</p></li><li><p>301    Moved Permanently    永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</p></li><li><p>302    Found    临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</p></li><li><p>303    See Other    查看其它地址。与301类似。使用GET和POST请求查看</p></li><li><p>304    Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p></li><li><p>305    Use Proxy    使用代理。所请求的资源必须通过代理访问</p></li><li><p>306    Unused    已经被废弃的HTTP状态码</p></li><li><p>307    Temporary Redirect    临时重定向。与302类似。使用GET请求重定向</p></li><li><p>400    Bad Request    客户端请求的语法错误，服务器无法理解</p></li><li><p>401    Unauthorized    请求要求用户的身份认证</p></li><li><p>402    Payment Required    保留，将来使用</p></li><li><p>403    Forbidden    服务器理解请求客户端的请求，但是拒绝执行此请求</p></li><li><p>404    Not Found    服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</p></li><li><p>405    Method Not Allowed    客户端请求中的方法被禁止</p></li><li><p>406    Not Acceptable    服务器无法根据客户端请求的内容特性完成请求</p></li><li><p>407    Proxy Authentication Required    请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</p></li><li><p>408    Request Time-out    服务器等待客户端发送的请求时间过长，超时</p></li><li><p>409    Conflict    服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</p></li><li><p>410    Gone    客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</p></li><li><p>411    Length Required    服务器无法处理客户端发送的不带Content-Length的请求信息</p></li><li><p>412    Precondition Failed    客户端请求信息的先决条件错误</p></li><li><p>413    Request Entity Too Large    由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</p></li><li><p>414    Request-URI Too Large    请求的URI过长（URI通常为网址），服务器无法处理</p></li><li><p>415    Unsupported Media Type    服务器无法处理请求附带的媒体格式</p></li><li><p>416    Requested range not satisfiable    客户端请求的范围无效</p></li><li><p>417    Expectation Failed    服务器无法满足Expect的请求头信息</p></li><li><p>500    Internal Server Error    服务器内部错误，无法完成请求</p></li><li><p>501    Not Implemented    服务器不支持请求的功能，无法完成请求</p></li><li><p>502    Bad Gateway    作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</p></li><li><p>503    Service Unavailable    由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</p></li><li><p>504    Gateway Time-out    充当网关或代理的服务器，未及时从远端服务器获取请求</p></li><li><p>505    HTTP Version not supported    服务器不支持请求的HTTP协议的版本，无法完成处理</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;状态码大全&quot;&gt;&lt;a href=&quot;#状态码大全&quot; class=&quot;headerlink&quot; title=&quot;状态码大全&quot;&gt;&lt;/a&gt;状态码大全&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;100    Continue    继续。客户端应继续其请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>cookie、session的区别</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A803-cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A803-cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-02T06:48:08.117Z</published>
    <updated>2021-07-02T06:49:35.453Z</updated>
    
    <content type="html"><![CDATA[<h3 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h3><ul><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>考虑到安全应当使用session。</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>考虑到减轻服务器性能方面，应当使用COOKIE。</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;cookie和session&quot;&gt;&lt;a href=&quot;#cookie和session&quot; class=&quot;headerlink&quot; title=&quot;cookie和session&quot;&gt;&lt;/a&gt;cookie和session&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;cookie数据存放在客户的浏览</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>http和https</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A802-http%E5%92%8Chttps/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A802-http%E5%92%8Chttps/</id>
    <published>2021-07-02T06:27:07.466Z</published>
    <updated>2021-07-02T06:32:07.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="http和https的基本概念"><a href="#http和https的基本概念" class="headerlink" title="http和https的基本概念"></a>http和https的基本概念</h3><ul><li><p>https的SSL加密是在传输层实现的。</p></li><li><p>http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p></li><li><p>https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p></li><li><p>https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p></li></ul><h3 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h3><ul><li><p>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</p></li><li><p>主要的区别如下：</p><ul><li><p>Https协议需要ca证书，费用较高。</p></li><li><p>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p></li><li><p>使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443</p></li><li><p>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p></li></ul></li></ul><h3 id="https协议的工作原理"><a href="#https协议的工作原理" class="headerlink" title="https协议的工作原理"></a>https协议的工作原理</h3><ul><li><p>客户使用https url访问服务器，则要求web 服务器建立ssl链接。</p></li><li><p>web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。</p></li><li><p>客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。</p></li><li><p>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</p></li><li><p>web服务器通过自己的私钥解密出会话密钥。</p></li><li><p>web服务器通过会话密钥加密与客户端之间的通信。</p></li></ul><h3 id="https协议的优点"><a href="#https协议的优点" class="headerlink" title="https协议的优点"></a>https协议的优点</h3><ul><li><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></li><li><p>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p></li><li><p>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p></li><li><p>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p></li></ul><h3 id="https协议的缺点"><a href="#https协议的缺点" class="headerlink" title="https协议的缺点"></a>https协议的缺点</h3><ul><li><p>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</p></li><li><p>https缓存不如http高效，会增加数据开销。</p></li><li><p>SSL证书也需要钱，功能越强大的证书费用越高。</p></li><li><p>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;http和https的基本概念&quot;&gt;&lt;a href=&quot;#http和https的基本概念&quot; class=&quot;headerlink&quot; title=&quot;http和https的基本概念&quot;&gt;&lt;/a&gt;http和https的基本概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;https的SSL</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>cookie、sessionStorage、localStorage的区别</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A801-cookie%E3%80%81sessionStorage%E3%80%81localStorage%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A801-cookie%E3%80%81sessionStorage%E3%80%81localStorage%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-02T05:54:26.358Z</published>
    <updated>2021-07-02T06:34:23.700Z</updated>
    
    <content type="html"><![CDATA[<h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ul><li>都是保存在浏览器端，并且是同源的。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>cookie：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约4K左右）。</li><li>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）。</li><li>localStorage：localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）。</li></ul><h3 id="cookie的作用"><a href="#cookie的作用" class="headerlink" title="cookie的作用"></a>cookie的作用</h3><ul><li>保存用户登录状态<ul><li>例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。</li></ul></li><li>跟踪用户行为<ul><li>例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;共同点&quot;&gt;&lt;a href=&quot;#共同点&quot; class=&quot;headerlink&quot; title=&quot;共同点&quot;&gt;&lt;/a&gt;共同点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;都是保存在浏览器端，并且是同源的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>18-Vue响应式原理</title>
    <link href="http://coderbxd.top/2021/06/19/23-Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://coderbxd.top/2021/06/19/23-Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-19T07:04:16.276Z</published>
    <updated>2021-07-02T06:15:58.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue是如何实现响应式的"><a href="#Vue是如何实现响应式的" class="headerlink" title="Vue是如何实现响应式的"></a>Vue是如何实现响应式的</h3><ul><li>Vue实现响应式要了解两个核心<ul><li>第一个: Vue如何监听data数据的改变</li><li>第二个: data数据改变的时候, Vue如何知道应该修改哪一个使用了data数据的元素</li></ul></li></ul><h3 id="Vue如何监听data数据的改变"><a href="#Vue如何监听data数据的改变" class="headerlink" title="Vue如何监听data数据的改变"></a>Vue如何监听data数据的改变</h3><ul><li>实质上vue是通过 defineProperty 方法来监听data数据的改变的</li><li>defineProperty方法需要传入三个参数<ul><li>第一个参数是需要监听的对象(目标对象)</li><li>第二个参数是监听对象的值(引用的目标对象上的字符串键属性)</li><li>第三个参数是一个对象, 对象中编写对应事件</li></ul></li></ul><h3 id="data数据改变的时候-Vue如何知道应该修改哪一个使用了data数据的元素"><a href="#data数据改变的时候-Vue如何知道应该修改哪一个使用了data数据的元素" class="headerlink" title="data数据改变的时候, Vue如何知道应该修改哪一个使用了data数据的元素"></a>data数据改变的时候, Vue如何知道应该修改哪一个使用了data数据的元素</h3><ul><li>vue是通过一种名叫 “发布者订阅者” 的模式来知道当data数据修改的时候, 应该修改哪一个使用了data数据的元素的</li></ul><h3 id="代码简单模拟vue的响应式原理"><a href="#代码简单模拟vue的响应式原理" class="headerlink" title="代码简单模拟vue的响应式原理"></a>代码简单模拟vue的响应式原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是简单地模拟一下vue的响应式原理</span></span><br><span class="line"><span class="comment">// vue实现响应式核心为两个</span></span><br><span class="line"><span class="comment">// 第一个: vue如何监听data数据的更改</span></span><br><span class="line"><span class="comment">// 第二个: vue如何知道应该修改页面中的哪个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先来解决第一个问题</span></span><br><span class="line"><span class="comment">// 实质上vue是通过defineProperty方法来监听数据的更改的</span></span><br><span class="line"><span class="comment">// 比如这里的obj对象就是vue中的data对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;xiaolam&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue中会获得这个obj对象, 然后遍历里面的键</span></span><br><span class="line"><span class="comment">// 通过 Object.keys(obj) 来获取obj中的键并组成一个数组</span></span><br><span class="line"><span class="comment">// 然后通过forEach 遍历这个数组, 给数组中的键通过defineProperty方法监听里面的所有key</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value = obj[key];</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="comment">// 通过defineProperty中的set方法就可以监听obj对象中数据的更改了</span></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;进入defineProperty中的set&quot;</span>);</span><br><span class="line">      <span class="comment">// 在更改obj中的数据的时候, 调用发布者中的notify方法, 这个方法会调用所有订阅者中的update方法</span></span><br><span class="line">      <span class="comment">// 而update方法里面可以编写更新页面的代码</span></span><br><span class="line">      dep.notify()</span><br><span class="line">      value = newValue</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 通过defineProperty中的get方法就可以监听页面中什么元素的通过mustache语法取用obj数据</span></span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;进入defineProperty中的get&quot;</span>);</span><br><span class="line">      <span class="comment">// 在使用obj的数据后, 将使用数据的元素做一个记录</span></span><br><span class="line">      <span class="comment">// 存储在发布者中</span></span><br><span class="line">      <span class="keyword">const</span> w1 = <span class="keyword">new</span> Watcher(<span class="string">&quot;w1&quot;</span>)</span><br><span class="line">      dep.addSub(w1)</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过上面的过程就可以实现第一个问题: vue如何实现监听data数据的更改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在解决第二个问题: vue如何知道应该修改页面中的哪个元素</span></span><br><span class="line"><span class="comment">// 实质上vue使用的是一个 发布者订阅者 的技术</span></span><br><span class="line"><span class="comment">// 发布者就是指vue实例</span></span><br><span class="line"><span class="comment">// 而订阅者就是指使用mustache语法的元素</span></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个数组用于存储订阅者</span></span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 在元素取用data数据的时候调用Dep中的这个方法, 来将元素(订阅者)加入到subs数组中用于记录订阅者都有谁</span></span><br><span class="line">  <span class="function"><span class="title">addSub</span>(<span class="params">watcher</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(watcher)</span><br><span class="line">  &#125;; </span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里做更新页面的操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;更新&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br></pre></td></tr></table></figure><ul><li>思路为: 订阅者和发布者是两个类, 在项目运行的时候, 就new对应的data属性发布者出来(一个data属性对应一个发布者), 在当有页面元素使用了data数据的时候, 触发了defineProperty中的get, 在get中new一个对应的订阅者出来, 并把这个订阅者通过对应发布者中的addSub方法记录在发布者中, 在data数据中某个属性发生改变的时候, 触发defineProperty中的set方法, 在set方法中调用对应发布者的notify方法, 这个方法会调用其中的每个订阅者中的update方法, 在update方法中就编写更新页面的操作, 就是这样发布者就知道应该让哪个订阅者更新自身的展示数据了, 从而实现响应式</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Vue是如何实现响应式的&quot;&gt;&lt;a href=&quot;#Vue是如何实现响应式的&quot; class=&quot;headerlink&quot; title=&quot;Vue是如何实现响应式的&quot;&gt;&lt;/a&gt;Vue是如何实现响应式的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Vue实现响应式要了解两个核心&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="VUE" scheme="http://coderbxd.top/tags/VUE/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>17-axios网络请求</title>
    <link href="http://coderbxd.top/2021/06/19/18-Vue-axios%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85/"/>
    <id>http://coderbxd.top/2021/06/19/18-Vue-axios%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85/</id>
    <published>2021-06-19T07:04:16.269Z</published>
    <updated>2021-07-02T06:24:04.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常见的网络请求模块-以及它们的优缺点对比"><a href="#常见的网络请求模块-以及它们的优缺点对比" class="headerlink" title="常见的网络请求模块, 以及它们的优缺点对比"></a>常见的网络请求模块, 以及它们的优缺点对比</h3><ul><li>传统Ajax请求<ul><li>缺点: 配置和调用方式等非常混乱</li><li>真实开发中真的很少直接使用, 而是使用Jquery-Ajax</li></ul></li><li>Jquery-ajax<ul><li>相对于传统的Ajax非常好用</li><li>但是我们在整个vue的开发中都是不需要使用Jquery的</li><li>那么就意味着为了方便我们进行一个网络请求, 特意引用了一个jQuery, 这显然不合理, Vue的代码才一万多行, jQuery的代码就一万多行了</li><li>完全没有必要为了使用网络请求就引用jQuery这个框架</li></ul></li><li>官方在Vue1.x的时候, 推出了Vue-resource<ul><li>Vue-resource的体积相对于jQuery小很多</li><li>而且Vue-resource是Vue官方推出的</li><li>但是在Vue2.0以后, Vue-resource就不再更新了</li><li>这就意味着如果继续使用Vue-resource的话对项目的开发和维护都存在很大的隐患</li></ul></li><li>axios<ul><li>在尤雨溪宣布不再更新vue-resource的时候, 推荐使用axios</li><li>所以就选axios了</li><li>vue作者都让你选这个了, 你还想啥呢?</li><li>可能你会说, 尤雨溪只是个写轮子的, 他懂个P的vue(/滑稽)</li></ul></li></ul><h3 id="axios的基本使用"><a href="#axios的基本使用" class="headerlink" title="axios的基本使用"></a>axios的基本使用</h3><ul><li>安装axios 在项目根目录下, 命令行输入<ul><li>npm install axios –save (运行时依赖)</li></ul></li><li>导入axios, 直接通过 axios() 使用, 并不需要使用Vue.use(axios) 来install, 因为axios本身并不是vue中的模块, vue并不具有axios的install方法</li><li>axios支持多种请求方式<ul><li>axios(config)</li><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]])</li></ul></li><li>但是我们一般使用第一个 axios(config) 因为这个灵活, 可以在config里面设置请求方式</li><li>axios的特点: axios() 在网络请求完成后会返回一个Promise对象, 所以我们可以在axios() 后直接使用then() 和catch() </li><li>请看下列代码实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios 是不需要使用 Vue.use() 方法, 因为axios并不是vue中的模块</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// axios有很多种请求方式, 默认的请求方式为get请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  <span class="comment">// 提问这里为什么没有跨域问题?</span></span><br><span class="line">  <span class="comment">// 因为在后端已经处理过跨域了</span></span><br><span class="line">  url : <span class="string">&quot;请求的url&quot;</span>,</span><br><span class="line">  <span class="comment">// 可以通过 method 属性来指定请求方式</span></span><br><span class="line">  method : <span class="string">&quot;post&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果使用get请求的话, 如果带有参数的话, 需要拼接到url上, 这样会导致url很长, 所以axios提供了一个parmas对象, 用于参数的拼接</span></span><br><span class="line">  params : &#123;</span><br><span class="line">    type : <span class="string">&quot;pop&quot;</span>,</span><br><span class="line">    page : <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// axios 在网络请求操作完成之后会返回一个 new Promise 对象, 所以这里可以使用then 和catch</span></span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios处理并发请求"><a href="#axios处理并发请求" class="headerlink" title="axios处理并发请求"></a>axios处理并发请求</h3><ul><li>如果我们需要多个axios请求完成后, 再进行下一步的操作</li><li>axios提供了一个 axios.all() 方法, 用于处理这种需求</li><li>这个方法里面传入一个数组, 数组中传入axios请求</li><li>在axios请求都完成后, axios.all() 方法会调用then(), then()中传入一个函数, 函数中有一个result参数</li><li>result是一个数组, 数组中第一个数据即是第一个axios请求返回的数据, 依此类推</li><li>如果想要将各个返回的数据分开的话, then() 中还可以传入一个 axios.spread() 方法, 方法中传入一个函数</li><li>该函数的参数就是对应的axios请求返回的数据</li><li>看以下实例代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios处理并发请求</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line">axios.all([</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url : <span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url : <span class="string">&quot;http://152.136.185.210:8000/api/w6/home/data&quot;</span>,</span><br><span class="line">    params : &#123;</span><br><span class="line">      type : <span class="string">&quot;pop&quot;</span>,</span><br><span class="line">      page : <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">])</span><br><span class="line"><span class="comment">/* .then((result =&gt; &#123;</span></span><br><span class="line"><span class="comment">  // 这里的result是一个数组, 里面按顺序存放了各个axios请求返回的数据</span></span><br><span class="line"><span class="comment">  console.log(result);</span></span><br><span class="line"><span class="comment">  console.log(result[0]);</span></span><br><span class="line"><span class="comment">  console.log(result[1]);</span></span><br><span class="line"><span class="comment">&#125;)) */</span></span><br><span class="line">.then(axios.spread(<span class="function">(<span class="params">res1, res2</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 axios.spread() 将各个axios请求返回的数据, 分开</span></span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios设置全局配置信息"><a href="#axios设置全局配置信息" class="headerlink" title="axios设置全局配置信息"></a>axios设置全局配置信息</h3><ul><li>其实我们的请求中有很多东西都是相同的, 比如url中的baseURL, 和设置的请求超时时间等等</li><li>如果我们每次请求都要重写这些config, 这样代码就很重复了</li><li>所以我们会将固定的参数抽取出来</li><li>axios提供了一个 defaults 对象用于进行全局配置</li><li>看以下代码实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line">axios.defaults.baseURL = <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span> <span class="comment">// 这里设置了baseURL</span></span><br><span class="line">axios.defaults.timeout = <span class="number">5000</span>  <span class="comment">// 这里设置了请求超时时间</span></span><br><span class="line">axios.all([</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url : <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url : <span class="string">&quot;/home/data&quot;</span>,</span><br><span class="line">    params : &#123;</span><br><span class="line">      type :<span class="string">&quot;pop&quot;</span>,</span><br><span class="line">      page : <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 axios.spread() 将各个axios请求返回的数据, 分开</span></span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="常见的axios配置项"><a href="#常见的axios配置项" class="headerlink" title="常见的axios配置项"></a>常见的axios配置项</h3><ul><li>请求地址<ul><li>url: ‘/user’,</li></ul></li><li>请求类型<ul><li>method: ‘get’,</li></ul></li><li>请根路径<ul><li>baseURL: ‘<a href="http://www.mt.com/api&#39;">http://www.mt.com/api&#39;</a>,</li></ul></li><li>请求前的数据处理<ul><li>transformRequest:[function(data){}],</li></ul></li><li>请求后的数据处理<ul><li>transformResponse: [function(data){}],</li></ul></li><li>自定义的请求头<ul><li>headers:{‘x-Requested-With’:’XMLHttpRequest’},</li></ul></li><li>URL查询对象 (注意只有get请求方式才用params)<ul><li>params:{ id: 12 }</li></ul></li><li>查询对象序列化函数<ul><li>paramsSerializer: function(params){ }</li></ul></li><li>request body (注意只用post请求方式才用这个)<ul><li>data: { key: ‘aa’},</li></ul></li><li>超时设置s<ul><li>timeout: 1000,</li></ul></li><li>跨域是否带Token<ul><li>withCredentials: false,</li></ul></li><li>自定义请求处理<ul><li>adapter: function(resolve, reject, config){},</li></ul></li><li>身份验证信息<ul><li>auth: { uname: ‘’, pwd: ‘12’},</li></ul></li><li>响应的数据格式 json / blob /document /arraybuffer / text / + stream<ul><li>responseType: ‘json’,</li></ul></li></ul><h3 id="创建axios实例"><a href="#创建axios实例" class="headerlink" title="创建axios实例"></a>创建axios实例</h3><ul><li>在实际开发中, 很有可能会遇到这种状况</li><li>网络请求的baseURL是不一样的, 或者说不同的网络请求设置的请求超时时间是不一样的</li><li>这个时候, 如果我们还是使用全局配置的 axios.default 就无法正确地请求正确的数据了</li><li>所以我们要创建axios实例</li><li>创建axios实例, 通过axios.create创建</li><li>看以下代码实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如这里的网络请求, 需要设置的请求超时时间为 5000毫秒</span></span><br><span class="line"><span class="keyword">const</span> instans1 = axios.create(&#123;</span><br><span class="line">  <span class="comment">// 在这里设置配置</span></span><br><span class="line">  baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span>,</span><br><span class="line">  timeout : <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在这里使用axios实例</span></span><br><span class="line"><span class="comment">// 与全局中使用axios基本一致</span></span><br><span class="line">instans1(&#123;</span><br><span class="line">  url : <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如这里需要设置请求超时时间为10000</span></span><br><span class="line"><span class="keyword">const</span> instans2 = axios.create(&#123;</span><br><span class="line">  baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span>,</span><br><span class="line">  timeout : <span class="number">10000</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在这里使用instans2进行网络请求</span></span><br><span class="line">instans2(&#123;</span><br><span class="line">  url : <span class="string">&quot;/home/data&quot;</span>,</span><br><span class="line">  params : &#123;</span><br><span class="line">    type :<span class="string">&quot;pop&quot;</span>,</span><br><span class="line">    page : <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h3><ul><li>如果我们没有把axios封装到一个文件中, 而是在需要用到axios的组件中都引用axios</li><li>那么如果在未来的某一天, axios突然宣布不再更新</li><li>那我们的项目想要使用另外的替代品将会变得十分困难, 因为我们每个组件都依赖了axios</li><li>为了降低我们各个组件对axios的依赖性</li><li>我们要将axios封装在一个独立的文件中</li><li>封装过程及引用方法请看下列示例代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文件 src/network/request.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios实例并导出</span></span><br><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span>,</span><br><span class="line">    timeout : <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  instans(config)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如何使用</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url : <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过组件传入一个函数, 然后回调这个函数返回数据给组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config,success,error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  instans(config)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    success(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    error(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如何使用</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span></span><br><span class="line">request(</span><br><span class="line">  &#123;</span><br><span class="line">    url: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="built_in">this</span>.res = res;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 通过组件传入一个函数, 然后回调这个函数返回数据给组件的另外一种形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  instans(config.baseConfig)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    config.success(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    config.error(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">request(&#123;</span><br><span class="line">  baseConfig: &#123;</span><br><span class="line">    url: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 实际上, 我们并不会使用以上的两种方法, 而是使用 Promise来返回数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    instans(config)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">request(&#123;</span><br><span class="line">    url: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.res = res;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1 实际上, 我们也不会像上面那样, 因为axios本身就返回一个Promise, 没有必要再包一层</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> instans(config)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.res = res;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="axios拦截器的使用"><a href="#axios拦截器的使用" class="headerlink" title="axios拦截器的使用"></a>axios拦截器的使用</h3><ul><li>axios提供了拦截器, 用于我们再发送每次请求或者得到相应数据后, 进行对应的处理</li><li>拦截器分为: 请求拦截器 interceptors.request 和 响应拦截器 interceptors.response</li><li>请求拦截器主要用法<ul><li>1.当发送网络请求的时候, 在页面中添加一个loading组件, 作为动画</li><li>2.某些请求是要求用户必须登陆的, 这是请求拦截器就可以判断请求是否带有token(令牌), 如果没有token就跳转到login页面</li><li>3.对请求的参数进行序列化, 就是对请求的参数做一些修改或者添加一些参数</li></ul></li><li>响应拦截器主要用法<ul><li>1.响应的成功拦截中,主要是对数据进行过滤</li><li>2.响应失败的拦截中, 跨域根据status判断报错的错误码, 跳转到不同的错误提示页面</li></ul></li><li>拦截器使用注意事项, 使用拦截器后, 一定要将数据 return 出去, 否则, 拦截器会把数据拦截住</li><li>基本使用方法看下列代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 使用拦截器</span></span><br><span class="line">  <span class="comment">// 请求拦截器</span></span><br><span class="line">  instans.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(config);</span><br><span class="line">    <span class="keyword">return</span> config  <span class="comment">// 将数据在return出去</span></span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应拦截器</span></span><br><span class="line">  instans.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> res.data  <span class="comment">// 将数据进行过滤, 只返回data</span></span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送真实的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> instans(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;常见的网络请求模块-以及它们的优缺点对比&quot;&gt;&lt;a href=&quot;#常见的网络请求模块-以及它们的优缺点对比&quot; class=&quot;headerlink&quot; title=&quot;常见的网络请求模块, 以及它们的优缺点对比&quot;&gt;&lt;/a&gt;常见的网络请求模块, 以及它们的优缺点对比&lt;/h3</summary>
      
    
    
    
    
    <category term="VUE" scheme="http://coderbxd.top/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>16-Vuex状态管理</title>
    <link href="http://coderbxd.top/2021/06/19/17-Vue-vuex%E8%AF%A6%E8%A7%A3/"/>
    <id>http://coderbxd.top/2021/06/19/17-Vue-vuex%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-06-19T07:04:16.264Z</published>
    <updated>2021-07-02T06:24:05.895Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是vuex"><a href="#什么是vuex" class="headerlink" title="什么是vuex"></a>什么是vuex</h3><ul><li>官方解释: Vuex是一个专门为Vue.js 应用程序开发的状态管理模式<ul><li>采用集中式存储管理应用的所有组件的状态, 并以相应的规则保证状态以一种可以预测的方式发生变化</li><li>Vuex 也继承到Vue官方调试工具 devtools extension, 提供了诸如零配置的 time-travel 调试 状态快照导入导出等高级调试功能</li></ul></li><li>官方解释其实有点晦涩难懂<ul><li>状态管理模式, 集中式存储管理其实</li><li>就是将需要多个组件共享的变量存储在一个对象中</li><li>然后将这个对象放在顶层的Vue实例中,让其他组件也可以使用</li><li>而且这个对象是响应式的, 这个优点是最牛逼的优点</li></ul></li><li>什么状态需要我们在多个组件间共享呢?<ul><li>用户的登陆状态,用户名称,头像,地理位置信息等等</li><li>商品的收藏,购物车中的物品<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以尝试一下自己写一下这个共享的对象</span></span><br><span class="line"><span class="comment">// 通过将数据集成在一个共享对象中, 然后将这个对象加入到Vue.prototype 原型对象中, 可以做到将对象中的数据共享出去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用给Vue.prototype Vue的原型对象添加一个对象来达到所有组件都可以访问这个对象</span></span><br><span class="line"><span class="keyword">const</span> shareObj = &#123;</span><br><span class="line">  name : <span class="string">&quot;xiaoLam&quot;</span>,</span><br><span class="line">  age : <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype.shareObj = shareObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是有一个问题, 这个共享对象不是响应式的, 所以我说vuex的共享数据是响应式的是最牛逼的优点</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="vuex基本使用"><a href="#vuex基本使用" class="headerlink" title="vuex基本使用"></a>vuex基本使用</h3><ul><li>vuex的安装<ul><li>在项目根目录下命令行输入 npm install vuex –save (运行时依赖安装)</li></ul></li><li>不建议在main.js中使用vuex</li><li>在项目目录下创建一个叫 store的文件夹, 里面创建一个名为 index.js 的文件, 在这个文件中编写vuex的代码</li><li>vuex插件基本使用 在store/index.js文件中<ul><li>引入 vue 和 vuex 因为vuex是依赖vue的</li><li>执行 Vue.use(Vuex) 执行 Vuex中的 install</li><li>创建Vuex实例: 注意,这里创建的是 Vuex.Store实例</li><li>在实例中创建一个 state对象, 在这个对象中写入想要共享的数据</li><li>导出实例</li></ul></li><li>在组件中使用vuex中的共享数据<ul><li>在main.js 中导入上面的实例</li><li>在根组件中注册store , 这样才可以在所有组件中通过 $store 获得store这个对象</li><li>在组件中使用 $store.state 获得这个包含共享数据的对象</li></ul></li><li>修改vuex中的共享数据<ul><li>其实我们可以通过 $store.state 来修改数据</li><li>但是vue官方不建议这样做</li><li>因为 State -&gt; Vue Components -&gt; Actions -&gt; Mutations -&gt; State 是一个单向循环</li><li>官方推荐做法是 我们通过 Vue Components 去修改 Actions 来修改 Mutations 最终达到修改 State 的目的</li><li>因为我们会需要知道是哪一个组件修改了State, 如果直接从 Vue Components 修改State的话就不能追踪是哪个组件修改了State</li><li>Backend API 会监测 Action的改变, Devtools 会监测 Mutations的改变, 按照官方的推荐做法就可以追踪是哪个组件修改了State</li><li>当然也可以跳过Actions, 通过 Vue Components -&gt; Mutations -&gt; State 修改 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是 store/index.js 文件的代码</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步: 引入插件后, 调用Vue.use() 来进行install Vuex</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步: 创建Vuex实例: 注意这里创建的是 Vuex中的Store实例</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state : &#123;</span><br><span class="line">    count : <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步: 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是main.js中的代码</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="comment">// 引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 在根组件中注册 store, 这样就可以在所用组件通过 $store 来获得store这个对象</span></span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用过$store.state 来获得store对象中的state中的共享数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.state.count &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>------------<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;hello-vuex :count=&quot;count&quot; /&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello-vuex</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果向修改vuex中的共享数据, 可以通过 $store.state修改, 但是官方不建议, 不推荐, 不允许这样修改 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后面会讲如何正确地修改vuex中的共享数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.state.count++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.state.count--&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue-devtools-和-mutations"><a href="#vue-devtools-和-mutations" class="headerlink" title="vue-devtools 和 mutations"></a>vue-devtools 和 mutations</h3><ul><li>什么是vuex-devtools<ul><li>这是一个vue官方的浏览器插件, 用于调试vue应用</li><li>这个插件可以用于监控mutations操作</li></ul></li><li>什么是mutations操作<ul><li>其实就是使用同步的操作去修改state共享数据</li></ul></li><li>简单来说, 浏览器插件vuex-devtools可以监控mutations操作, 达到追踪是什么组件修改了state共享数据的效果</li></ul><h3 id="vue-devtools-和-mutations-的使用的注意事项"><a href="#vue-devtools-和-mutations-的使用的注意事项" class="headerlink" title="vue-devtools 和 mutations 的使用的注意事项"></a>vue-devtools 和 mutations 的使用的注意事项</h3><ul><li><p>浏览器安装vue-devtools</p><ul><li>chrome应用商店搜索, vue.js devtools 安装即可</li><li>如果进入不了chrome应用商店, 可以离线下载谷歌访问助手</li><li>安装完成后会在浏览器开发者工具中多了一个”vue”选项卡</li></ul></li><li><p>通过mutations来修改state共享数据</p><ul><li>在 store/index.js 中的Vuex.Store实例中创建 mutations对象</li><li>在对象中编写方法</li><li>mutations中的方法默认会有一个名为state的参数, 这个state就是 state共享数据对象</li><li>定义好方法后, 通过提交的方式来调用方法</li><li>具体看以下代码</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是store/index.js 中的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state : &#123;</span><br><span class="line">    count : <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建mutations 对象</span></span><br><span class="line">  mutations : &#123;</span><br><span class="line">    <span class="comment">// mutations 中的方法中默认会传入一个state的参数, 这个参数就是上面定义的state对象</span></span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是组件中定义的methods</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">addtion</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里并不是直接使用 this.$store.mutation.increment() 来执行increment这个方法</span></span><br><span class="line">    <span class="comment">// 而是用 this.$store.commit(&quot;方法名&quot;) 来提交要使用的方法</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;increment&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">subtraction</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;decrement&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="以上就是Vuex最简单的使用了"><a href="#以上就是Vuex最简单的使用了" class="headerlink" title="以上就是Vuex最简单的使用了"></a>以上就是Vuex最简单的使用了</h3><ul><li>1.提取出一个公共的store对象，用于保存在多个组件中共享的状态</li><li>2.将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到</li><li>3.在其他组件中使用store对象中保存的状态即可<ul><li>通过this.$store.state.属性的方式来访问状态</li><li>通过this.$store.commit(‘mutation中方法’)来修改状态</li></ul></li><li>注意事项：<ul><li>我们通过提交mutation的方式，而非直接改变store.state.count。</li><li>这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。</li></ul></li></ul><h3 id="Vuex的核心概念"><a href="#Vuex的核心概念" class="headerlink" title="Vuex的核心概念"></a>Vuex的核心概念</h3><ul><li>State, Getters, Mutation, Action, Module</li></ul><h3 id="Vuex概念理解-State单一状态树"><a href="#Vuex概念理解-State单一状态树" class="headerlink" title="Vuex概念理解-State单一状态树"></a>Vuex概念理解-State单一状态树</h3><ul><li>Vuex提出单一状态树, 什么是单一状态树呢?<ul><li>单一状态树英文名称为 Single Source of Truth 也可以翻译成单一数据源</li></ul></li><li>简单来说, 就是将所有的数据都放在同一个Store对象中, 不要因为数据的类型不同, 数据量多而分开放</li><li>如果我们将数据保存在多个Store对象中的话, 那么之后的管理和维护等都会变得特别困难</li><li>所以Vuex推荐使用单一状态树来管理应用层级的全部状态</li><li>单一状态树能够让我们用最直接的方式找到某个状态的片段,而且在以后的维护和调试过程中, 也可以非常方便地管理和维护</li><li>总的来说, 就是不要创建多个Store对象, 只创建一个!!! 所有数据, 所有方法, 都放在这个Store对象中</li></ul><h3 id="Vuex核心概念之-getters"><a href="#Vuex核心概念之-getters" class="headerlink" title="Vuex核心概念之 getters"></a>Vuex核心概念之 getters</h3><ul><li>如果我们需要将state中的共享数据经过处理后再将其渲染在页面中的话, 就需要使用 Vuex中的getters对象</li><li>实质上, getters 相当于Vue中的计算属性 computed</li><li>getters的使用<ul><li>在Vue.store实例中定义getters对象</li><li>在getters对象中定义方法</li><li>在getters对象中的方法都具有两个参数, state 和 getters<ul><li>state参数指向state对象</li><li>getters参数指向getters对象</li></ul></li><li>getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</li><li>在组件中通过 $store.getters 来获得这个getters对象</li></ul></li><li>具体使用方法看下列代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是 store/index.js 的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state : &#123;</span><br><span class="line">    count : <span class="number">100</span>,</span><br><span class="line">    students : [</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>, <span class="attr">age</span>:<span class="number">18</span> &#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">112</span>, <span class="attr">name</span>: <span class="string">&quot;suoer&quot;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">113</span>, <span class="attr">name</span>: <span class="string">&quot;yangcong&quot;</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters : &#123;</span><br><span class="line">    <span class="comment">// 在我们需要将共享数据进行处理后再展示在页面的情况下, 就需要使用getters对象, 相当于计算属性computed</span></span><br><span class="line">    <span class="comment">// getters中的方法也是有一个state参数, 指向state对象</span></span><br><span class="line">    <span class="function"><span class="title">powerCount</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 需求1, 过滤state中的students, 取出年龄大于15的</span></span><br><span class="line">    <span class="function"><span class="title">getAge15</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">students</span> =&gt;</span> students.age &gt; <span class="number">15</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 需求2, 获得年龄大于15的student的个数</span></span><br><span class="line">    <span class="function"><span class="title">getAge15Num</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// return state.students.filter(students =&gt; students.age &gt; 15).length</span></span><br><span class="line">      <span class="comment">// getters对象中的方法, 除了state这个参数外, 还有getters参数, 这个参数指向getters对象</span></span><br><span class="line">      <span class="comment">// 所以上面的写法可以写成</span></span><br><span class="line">      <span class="keyword">return</span> getters.getAge15.length</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 需求3, 想要通过用户输入的年龄, 来决定输出大于该年龄的student</span></span><br><span class="line">    <span class="comment">// getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</span></span><br><span class="line">    <span class="comment">// 要达到这个需求的话, 需要在方法中返回一个函数, 具体如下</span></span><br><span class="line">    <span class="comment">// 思路是return出去一个函数, 这个函数有一个形参, 这个形参由用户来决定</span></span><br><span class="line">    <span class="function"><span class="title">getAge</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">students</span> =&gt;</span> students.age &gt; age)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过$store.getters 来获取getters中的数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.powerCount &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.getAge15 &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.getAge15Num &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传入参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.getAge(17) &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Vuex核心概念之-mutations"><a href="#Vuex核心概念之-mutations" class="headerlink" title="Vuex核心概念之 mutations"></a>Vuex核心概念之 mutations</h3><ul><li>Vuex的store状态的更新唯一方式是: 提交 Muattion</li><li>Mutation主要包括两个部分<ul><li>字符串的事件类型(type)</li><li>一个回调函数是(handler), 这个回调函数的第一个参数就是state 指向state对象</li></ul></li><li>mutation的基本使用<ul><li>在 store/index.js 中的Vue.store实例中创建 mutations对象</li><li>这个对象中编写方法</li><li>这个对象中的方法中的第一个参数为 state , 指向state对象</li><li>后面的参数是Vue Components传递过来的额外参数(称为载荷Payload)</li><li>定义好方法后, 在组件中使用 $state.commit(“事件类型”) 提交, 达到更新状态的效果</li><li>具体使用看下列代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些是 store/index.js 中的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state : &#123;</span><br><span class="line">    count : <span class="number">100</span>,</span><br><span class="line">    students : [</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>, <span class="attr">age</span>:<span class="number">18</span> &#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">112</span>, <span class="attr">name</span>: <span class="string">&quot;suoer&quot;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">113</span>, <span class="attr">name</span>: <span class="string">&quot;yangcong&quot;</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建mutations 对象</span></span><br><span class="line">  mutations : &#123;</span><br><span class="line">    <span class="comment">// mutations 中的方法中默认会传入一个state的参数, 这个参数就是上面定义的state对象</span></span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count--</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 如果在mutations更新数据的时候, 携带一些参数的时候</span></span><br><span class="line">    <span class="function"><span class="title">incrementCount</span>(<span class="params">state, count</span>)</span> &#123;</span><br><span class="line">      state.count += count</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 如果参数的个数不是一个的时候, 我们可以传入一个对象</span></span><br><span class="line">    <span class="function"><span class="title">addStudent</span>(<span class="params">state,student</span>)</span> &#123;</span><br><span class="line">      state.students.push(student)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这些是组件中的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果向修改vuex中的共享数据, 可以通过 $store.state修改, 但是官方不建议, 不推荐, 不允许这样修改 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;button @click=&quot;$store.state.count++&quot;&gt;+&lt;/button&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;button @click=&quot;$store.state.count--&quot;&gt;-&lt;/button&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 官方建议这样来修改vuex中的共享数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addtion&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;subtraction&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addCount(5)&quot;</span>&gt;</span>+5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addCount(10)&quot;</span>&gt;</span>+10<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addStudent&quot;</span>&gt;</span>添加学生<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// ..</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// ...</span></span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addtion</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里并不是直接使用 this.$store.mutation.increment() 来执行increment这个方法</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 而是用 this.$store.commit(&quot;方法名&quot;) 来提交要使用的方法</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;increment&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">subtraction</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;decrement&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果带有参数(载荷)， 则在 $store.commit(&quot;事件类型&quot;, 载荷)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$store.commit(&quot;incrementCount&quot;, count);</span></span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="comment">// </span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addStudent</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> student = &#123; <span class="attr">id</span>: <span class="number">115</span>, <span class="attr">name</span>: <span class="string">&quot;wuming&quot;</span>, <span class="attr">age</span>: <span class="number">40</span> &#125;;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果参数不止一个, 载荷也可以是一个对象</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;addStudent&quot;</span>, student);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Mutation提交风格"><a href="#Mutation提交风格" class="headerlink" title="Mutation提交风格"></a>Mutation提交风格</h3><ul><li>上面的通过commit进行提交时一种普通的方式</li><li>Vue还提供了另外一种风格, 它是一个包含type属性的对象</li><li>提交的风格不同, Mutation中的处理方式也会不同<ul><li>普通的提交方式, mutations中的payload就是传入的参数</li><li>包含type属性的对象提交风格, mutations中的payload是整个commit提交的对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 普通的提交风格</span></span><br><span class="line">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;incrementCount&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一个包含type属性的对象提交风格</span></span><br><span class="line">      <span class="built_in">this</span>.$store.commit(&#123;</span><br><span class="line">        type: <span class="string">&quot;incrementCount&quot;</span>, <span class="comment">// type属性, 值为 &quot;事件类型&quot;</span></span><br><span class="line">        count, <span class="comment">// 后面跟的是需要传入的参数</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mutations : &#123;</span><br><span class="line">  <span class="comment">// 如果在mutations更新数据的时候, 携带一些参数的时候</span></span><br><span class="line">  <span class="function"><span class="title">incrementCount</span>(<span class="params">state, count</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 下文的 payload 指 count形参</span></span><br><span class="line">    <span class="comment">// 普通的提交风格接收参数, 这个 payload 就是传入的参数</span></span><br><span class="line">    <span class="comment">// state.count += count</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个包含type属性的对象提交的时候, 这个payload就不是传入的参数了, 而是整个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(count); <span class="comment">// &#123;type: &quot;incrementCount&quot;, count: 5&#125;</span></span><br><span class="line">    <span class="comment">// 要获得传入的参数, 则是 payload.count</span></span><br><span class="line">    state.count += count.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutation的响应式规则"><a href="#Mutation的响应式规则" class="headerlink" title="Mutation的响应式规则"></a>Mutation的响应式规则</h3><ul><li>Vuex的store中的state是响应式的, 当state中的数据发生改变的时候, Vue组件也会跟着自动更新</li><li>如果我们想要使用响应式, 那么我们必须遵守一些Vuex的规则<ul><li>拥有响应式的数据必须提前在state中初始化所需的属性</li></ul></li><li>例如: 如果我们给一个对象添加一个新属性的话, 这个操作不是响应式的, 因为这个新属性没有提前在state中初始化</li><li>又例如: 我们给一个对象删除一个属性, 这个操作也不是响应式的</li><li>那么我们如何让这些操作达到响应式的效果呢?<ul><li>这是要是用 Vue.set() 和 Vue.delete() 这两个方法了<ul><li>Vue.set(要修改的数组或对象, Number/String, 修改后的值)</li><li>Vue.delete(要修改的数组或对象, Number/String)</li></ul></li><li>这两个方法Vue中的内部操作就是, 将要修改的属性添加到 Vue中的响应式系统中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state : &#123;</span><br><span class="line">    info : &#123; <span class="attr">id</span> : <span class="number">102</span>, <span class="attr">name</span> : <span class="string">&quot;fanghuonv&quot;</span>, <span class="attr">age</span> : <span class="number">16</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  mutations : &#123;</span><br><span class="line">    <span class="function"><span class="title">infoUpdate</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 如果给state中的对象属性修改值, 这个操作是响应式的, 因为修改的属性提前在state种初始化了</span></span><br><span class="line">      <span class="comment">// state.info.age = 19;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果给state中的对象添加新的属性, 这个操作不是响应式的, 因为这个新属性并没有提前在state中初始化</span></span><br><span class="line">      <span class="comment">// state.info[&quot;address&quot;] = &quot;jisichang&quot;</span></span><br><span class="line">      <span class="comment">// 如果要想这个操作也变成响应式的话, 就要使用Vue.set(要修改的数组或对象, Number/String, 修改后的值)</span></span><br><span class="line">      <span class="comment">// Vue.set(state.info, &quot;address&quot;, &quot;jisichang&quot;) </span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果给state中的对象删除属性, 这个操作也不是响应式的</span></span><br><span class="line">      <span class="comment">// delete state.info.id;</span></span><br><span class="line">      <span class="comment">// 如果想要这个操作也变成响应式的话, 就要使用Vue.delete(要修改的数组或对象, Number/String)</span></span><br><span class="line">      Vue.delete(state.info, <span class="string">&quot;id&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Vue.set() 和 Vue.delete() 这两个方法内部会将 要修改的属性也一起添加到Vue的响应式系统里面了 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Mutation常量类型"><a href="#Mutation常量类型" class="headerlink" title="Mutation常量类型"></a>Mutation常量类型</h3><ul><li>在mutation中, 我们定义了很多事件类型(也就是其中的方法名称)</li><li>当我们的项目越来越大的时候, Vuex管理的状态越来越多, 需要更新状态的情况也越来越多, 那么就意味着Mutation中的方法越来越多</li><li>方法过多的时候, 使用者需要花费大量的精力去记住这些方法,甚至是多个文件间切换, 查看方法名称, 甚至如果不是复制方法名称的时候, 还有可能出现写错的情况</li><li>那么如何解决上述的问题呢?<ul><li>一种常见的方案就是使用常量替代Mutation事件类型</li><li>我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型都一目了然</li></ul></li><li>具体做法<ul><li>在store文件夹中创建一个名为 mutations-type.js 的文件</li><li>定义mutation方法的时候, 可以使用ES2015中的风格, 使用一个常量来作为函数的名称<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是store/mutations-type.js中的代码</span></span><br><span class="line"><span class="comment">// 在这里定义常量 用于 替代Mutation事件类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">&quot;increment&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT =<span class="string">&quot;decrement&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT_COUNT =<span class="string">&quot;incrementCount&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_STUDENT = <span class="string">&quot;addStudent&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INFO_UPDATE = <span class="string">&quot;infoUpdate&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里是组件中的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 引入定义常量名称的文件</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;</span></span><br><span class="line">  INCREMENT,</span><br><span class="line">  DECREMENT,</span><br><span class="line">  INCREMENT_COUNT,</span><br><span class="line">  ADD_STUDENT,</span><br><span class="line">  INFO_UPDATE,</span><br><span class="line"><span class="javascript">&#125; <span class="keyword">from</span> <span class="string">&quot;./store/mutations-type&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// ...</span></span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addtion</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里就可以直接使用常量名字代替mutation事件类型了</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(INCREMENT);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是 store/index.js 中的文件</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  INCREMENT,</span><br><span class="line">  DECREMENT,</span><br><span class="line">  INCREMENT_COUNT,</span><br><span class="line">  ADD_STUDENT,</span><br><span class="line">  INFO_UPDATE,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./mutations-type&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  mutations : &#123;</span><br><span class="line">    <span class="comment">// 定义mutation方法的时候, 可以使用ES2015中的风格, 使用一个常量来作为函数的名称</span></span><br><span class="line">    [INCREMENT](state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mutation同步函数"><a href="#Mutation同步函数" class="headerlink" title="Mutation同步函数"></a>Mutation同步函数</h3><ul><li>通常情况下, Vuex要求我们的Mutation中的方法必须都是同步方法<ul><li>原因是, 当我们使用devtools时, devtools可以帮助我们捕捉mutation的快照</li><li>但是如果时异步操作的话, devtools就不能追踪这个异步操作是什么时候被完成</li></ul></li><li>所以, 通常情况下, 不能在mutation种进行异步操作</li></ul><h3 id="Action的基本定义"><a href="#Action的基本定义" class="headerlink" title="Action的基本定义"></a>Action的基本定义</h3><ul><li>如果我们需要在Vuex中进行一些异步操作, 比如网络请求</li><li>这个时候我们就要将异步操作在actions中进行</li><li>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的<ul><li>actions中定义方法与在mutation中定义方法的方式基本一样</li><li>要注意的是, actions中的方法中第一个参数不是state 而是 context<ul><li>context 意为 上下文, 指向store 对象</li></ul></li><li>还有一点, 组件中向actions提交事件类型, 并不是通过 commit, 而是通过 dispatch</li></ul></li><li>actions的基本使用<ul><li>注意: 我们不可以直接在actions中通过异步操作直接更新store的状态</li><li>更新store的状态的唯一方式为 mutations</li><li>所以actions中的方法实质上只是一个中转站, 更新store的状态这个操作最终还是要在mutations中进行<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是store/index.js中的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  mutations : &#123;</span><br><span class="line">    [INFO_UPDATE](state) &#123;</span><br><span class="line">      <span class="comment">// actions中的方法最终还是要回到mutations中来更新store的状态</span></span><br><span class="line">      state.info.name = <span class="string">&quot;huixinge&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions : &#123;</span><br><span class="line">    <span class="comment">// 在actions中编写方法, 跟在mutations中编写方法差不多, 但是方法中传入的第一个参数并不是state, 而是 context</span></span><br><span class="line">    <span class="comment">// context意为 上下文, 可以理解为store这个对象</span></span><br><span class="line">    <span class="comment">// 如果想要传入参数, 也是跟mutations中的方法一样, 也是有普通方式, 和传入一个包含type属性的对象方式</span></span><br><span class="line">    [A_INFO_UPDATE](context) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 注意, 不能再actions的方法中更新store的状态, 要记住一点, 更新store状态的唯一方式是mutations中的方法</span></span><br><span class="line">        <span class="comment">// 所以这里做的操作是使用 commit 提交</span></span><br><span class="line">        context.commit(INFO_UPDATE)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求, 需要异步操作完成后, 给组件返回一个信息</span></span><br><span class="line">    <span class="comment">// 第一种方式, 通过组件传参的时候传入一个函数, 在actions中进行异步操作, 异步操作完成后回调这个函数</span></span><br><span class="line">    [A_INFO_UPDATE](context, payload) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 注意, 不能再actions的方法中更新store的状态, 要记住一点, 更新store状态的唯一方式是mutations中的方法</span></span><br><span class="line">        <span class="comment">// 所以这里做的操作是使用 commit 提交</span></span><br><span class="line">        context.commit(INFO_UPDATE)</span><br><span class="line">        <span class="built_in">console</span>.log(payload.message);</span><br><span class="line">        payload.finsh();</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种方式不够优雅, vue官方推荐我们通过 return 一个new Promise 对象来实现</span></span><br><span class="line">    [A_INFO_UPDATE](context, payload) &#123;</span><br><span class="line">      <span class="comment">// 在这里return 出去的是回到组件那里的, 所以组件那里的代码可以用then</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          context.commit(INFO_UPDATE)</span><br><span class="line">          <span class="built_in">console</span>.log(payload.message);</span><br><span class="line">          resolve(<span class="string">&quot;完成了完成了&quot;</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是组件中的代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">aInfoUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 提交给actions 要用 dispatch 而不是commit</span></span><br><span class="line">      <span class="comment">// commit是提交给mutations的</span></span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(A_INFO_UPDATE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第一种方式: 通过传入一个函数, 在异步操作完成后进行回调</span></span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(&#123;</span><br><span class="line">        type: A_INFO_UPDATE,</span><br><span class="line">        message: <span class="string">&quot;你好你好&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">finsh</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;完成了&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第二种方式: 通过 Promise 对象</span></span><br><span class="line">      <span class="built_in">this</span>.$store</span><br><span class="line">        .dispatch(&#123;</span><br><span class="line">          type: A_INFO_UPDATE,</span><br><span class="line">          message: <span class="string">&quot;你好你好&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// actions中return回来的 Promise 是在这里的, 所以这里能用then</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="认识Module"><a href="#认识Module" class="headerlink" title="认识Module"></a>认识Module</h3><ul><li>Module是模块的意思, 为什么在Vuex中我们要使用模块呢?<ul><li>Vue使用单一状态树, 那就意味着很多状态都会交给同一个store管理</li><li>当应用变得非常复杂的时候, store对象就会变得十分臃肿</li><li>为了解决这个问题啊,Vuex允许我们将store分割成模块(Module), 而每个模块都拥有自己的state, mutations, actions, getters</li></ul></li><li>实质就是将共性多的store抽离出去, 这样易于后期维护</li><li>在Module中的 state, mutations, actions, getters 和原来的没有什么区别</li><li>只是有一些需要注意的点<ul><li><ol><li>在组件中想要使用模块中的state共享数据, 通过 $store.state.模块名.数据名 , 来获取</li></ol></li><li><ol start="2"><li>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象.</li></ol></li><li><ol start="3"><li>在actions中的第一个参数里面 可以通过 context.rootState 来获取根的state</li></ol></li><li><ol start="4"><li>在actions中使用 context.commit(“事件类型”) 是提交给模块中的mutations, 而不是根的</li></ol></li><li><ol start="5"><li>在getters的方法中, 拥有第三个参数 rootState, 这个参数指向根的state</li></ol></li><li><ol start="6"><li>其余大多数使用方法与原本的一致</li></ol></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ModuleA = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name : <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    <span class="comment">// 在组件中如果要获取这个name, 则是通过 $store.state.ModuleA.name 来获取</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters : &#123;</span><br><span class="line">    <span class="function"><span class="title">fullName</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.name + <span class="number">111</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullName2</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullName + <span class="number">222</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 除了基本的写法外, 模块中的getters中的函数还有第三个参数, 为 rootState, 指向根的state</span></span><br><span class="line">    <span class="function"><span class="title">fullName3</span>(<span class="params">state,getters,rootState</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullName2 + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations : &#123;</span><br><span class="line">    <span class="function"><span class="title">nameUpdate</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      state.name = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions : &#123;</span><br><span class="line">    <span class="comment">// context 意为上下文 所以这里指向这个模块</span></span><br><span class="line">    <span class="function"><span class="title">AnameUpdate</span>(<span class="params">context,payload</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(context);</span></span><br><span class="line">        context.commit(<span class="string">&quot;nameUpdate&quot;</span>, payload)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state : &#123;</span><br><span class="line">    count : <span class="number">100</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  modules : &#123;</span><br><span class="line">    ModuleA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul><li>当我们Vuex帮助我们管理过多内容的时候, 会发现index.js文件变得很乱, 我们要将index.js文件解构, 让我们的代码更加清晰</li><li>以下操作都在store文件夹中进行<ul><li>创建getters.js文件, 将index.js中的getters对象抽取到这个文件中</li><li>创建mutations.js文件, 将index.js中的mutations对象抽取到这个文件中</li><li>创建actions.js文件, 将index.js中的actions对象抽取到这个文件中</li><li>创建modules文件夹, 里面创建ModuleA.js文件, 将ModuleA模块抽取到这个文件中</li></ul></li><li>这样我们的代码就变得很清晰了, 方便后期的维护和更新</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是vuex&quot;&gt;&lt;a href=&quot;#什么是vuex&quot; class=&quot;headerlink&quot; title=&quot;什么是vuex&quot;&gt;&lt;/a&gt;什么是vuex&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;官方解释: Vuex是一个专门为Vue.js 应用程序开发的状态管理模式&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="VUE" scheme="http://coderbxd.top/tags/VUE/"/>
    
  </entry>
  
</feed>
