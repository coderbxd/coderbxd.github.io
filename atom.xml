<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coderbxd的博客</title>
  
  <subtitle>重庆移通学院 2022 软件工程</subtitle>
  <link href="http://coderbxd.top/atom.xml" rel="self"/>
  
  <link href="http://coderbxd.top/"/>
  <updated>2021-07-03T09:23:03.601Z</updated>
  <id>http://coderbxd.top/</id>
  
  <author>
    <name>bxd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>px,em,rem的区别</title>
    <link href="http://coderbxd.top/2021/07/03/css06-px,em,rem%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://coderbxd.top/2021/07/03/css06-px,em,rem%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-03T09:01:07.125Z</published>
    <updated>2021-07-03T09:23:03.601Z</updated>
    
    <content type="html"><![CDATA[<h3 id="px-em-rem的区别"><a href="#px-em-rem的区别" class="headerlink" title="px,em,rem的区别"></a>px,em,rem的区别</h3><ul><li><p>px </p><ul><li>px 像素 绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一<br>个虚拟长度单位，是计算机系统的数字化图像长度单位</li></ul></li><li><p>em </p><ul><li>em是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字<br>体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大<br>小，因此并不是一个固定的值</li></ul></li><li><p>rem </p><ul><li>rem是CSS3 新增的一个相对单位（root em，根 em），使用 rem 为元素设定字<br>体大小时，仍然是相对大小，但相对的只是 HTML 根元素</li></ul></li><li><p>区别<br>IE 无法调整那些使用 px 作为单位的字体大小，而 em 和 rem 可以缩放，rem<br>相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通<br>过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐<br>层复合的连锁反应。目前，除了 IE8 及更早版本外，所有浏览器均已支持rem</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;px-em-rem的区别&quot;&gt;&lt;a href=&quot;#px-em-rem的区别&quot; class=&quot;headerlink&quot; title=&quot;px,em,rem的区别&quot;&gt;&lt;/a&gt;px,em,rem的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;px &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;px 像</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css中那些属性可继承，哪些不可以？</title>
    <link href="http://coderbxd.top/2021/07/03/css05-%E5%8F%AF%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
    <id>http://coderbxd.top/2021/07/03/css05-%E5%8F%AF%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7/</id>
    <published>2021-07-03T08:49:09.605Z</published>
    <updated>2021-07-03T09:00:46.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="能继承的属性"><a href="#能继承的属性" class="headerlink" title="能继承的属性"></a>能继承的属性</h3><ul><li>字体系列属性<ul><li>font</li></ul></li><li>文本系列属性<ul><li>内联元素：color, line-height, word-spacing, letter-spacing, text-transform</li><li>块级元素：text-indent, text-align</li></ul></li><li>元素可见性<ul><li>visiblity</li></ul></li><li>表格布局属性<ul><li>caption-side, border-collapse, border-spacing, empty-cells, table-layout</li></ul></li><li>列表布局属性<ul><li>list-style</li></ul></li></ul><h3 id="不能继承的属性"><a href="#不能继承的属性" class="headerlink" title="不能继承的属性"></a>不能继承的属性</h3><ul><li>display<ul><li>规定元素应该生成的框的类型</li></ul></li><li>文本属性<ul><li>vertical-align, text-decoration</li></ul></li><li>盒子模型的模型<ul><li>width, height, margin, border, padding</li></ul></li><li>背景属性<ul><li>background, background-image, background-color</li></ul></li><li>定位属性<ul><li>float, clear, position, top, right, bottom, left, min-width, min-height<br>, max-width, max-height, overflow, clip</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;能继承的属性&quot;&gt;&lt;a href=&quot;#能继承的属性&quot; class=&quot;headerlink&quot; title=&quot;能继承的属性&quot;&gt;&lt;/a&gt;能继承的属性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;字体系列属性&lt;ul&gt;
&lt;li&gt;font&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文本系列属性&lt;</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>input元素type属性值</title>
    <link href="http://coderbxd.top/2021/07/03/html02-h5input%E5%85%83%E7%B4%A0type%E5%80%BC/"/>
    <id>http://coderbxd.top/2021/07/03/html02-h5input%E5%85%83%E7%B4%A0type%E5%80%BC/</id>
    <published>2021-07-03T08:14:35.843Z</published>
    <updated>2021-07-03T09:09:30.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="H5-input元素type属性值"><a href="#H5-input元素type属性值" class="headerlink" title="H5 input元素type属性值"></a>H5 input元素type属性值</h3><ul><li>button 按钮</li><li>checkout 复选框</li><li>color 颜色</li><li>date 定义日期字段</li><li>month 定义日期字段的月</li><li>time 日期字段的时、分、秒</li><li>email 定义用于 e-mail地址的文本字段</li><li>file 定义输入字段和”浏览…” 按钮，供文件上传</li><li>hidden 隐藏输入字段</li><li>image 定义图像作为提交按钮</li><li>number 定义带有 spinner 控件的数字字段</li><li>password 定义密码字段。字段中的字符会被遮蔽。</li><li>radio 定义单选按钮。</li><li>search 定义用于搜索的文本字段。</li><li>submit 定义提交按钮。提交按钮向服务器发送数据。</li><li>text 默认。定义单行输入字段，用户可在其中输入文本。默认是 20 个字符。</li><li>url 定义用于 URL 的文本字段。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;H5-input元素type属性值&quot;&gt;&lt;a href=&quot;#H5-input元素type属性值&quot; class=&quot;headerlink&quot; title=&quot;H5 input元素type属性值&quot;&gt;&lt;/a&gt;H5 input元素type属性值&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;butt</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="HTML" scheme="http://coderbxd.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>css选择器优先级</title>
    <link href="http://coderbxd.top/2021/07/03/css04-css%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://coderbxd.top/2021/07/03/css04-css%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7/</id>
    <published>2021-07-03T06:49:51.859Z</published>
    <updated>2021-07-03T08:15:18.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><ul><li>!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</li><li>权重 <ul><li>css权重是由四个数值决定</li><li>第一等：内联样式：style = “”, 权值1000 不推荐使用，不利于管理</li><li>第二等：ID选择器：#header，权值100</li><li>第三等： 类，伪类，属性选择器：.bar，权值10</li><li>第四等：标签，伪元素选择器：div::first-line，权值1</li><li>将所有值相加就是当前元素的权重</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;权重&quot;&gt;&lt;a href=&quot;#权重&quot; class=&quot;headerlink&quot; title=&quot;权重&quot;&gt;&lt;/a&gt;权重&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;!important &amp;gt; 行内样式 &amp;gt; ID选择器 &amp;gt; 类选择器 &amp;gt; 标签 &amp;gt; 通配符 &amp;gt; </summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>css盒模型</title>
    <link href="http://coderbxd.top/2021/07/03/css03-%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <id>http://coderbxd.top/2021/07/03/css03-%E7%9B%92%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-07-03T06:30:49.724Z</published>
    <updated>2021-07-03T06:49:36.183Z</updated>
    
    <content type="html"><![CDATA[<h3 id="盒子模型可以用来对元素进行布局，包括内边距，边框，外边距和实际内容"><a href="#盒子模型可以用来对元素进行布局，包括内边距，边框，外边距和实际内容" class="headerlink" title="盒子模型可以用来对元素进行布局，包括内边距，边框，外边距和实际内容"></a>盒子模型可以用来对元素进行布局，包括内边距，边框，外边距和实际内容</h3><h3 id="盒子模型分为两种"><a href="#盒子模型分为两种" class="headerlink" title="盒子模型分为两种"></a>盒子模型分为两种</h3><ul><li>W3C 标准的盒子模型（标准盒模型）</li><li>IE 标准的盒子模型（怪异盒模型）</li></ul><h3 id="标准盒模型与怪异盒模型的表现效果的区别之处"><a href="#标准盒模型与怪异盒模型的表现效果的区别之处" class="headerlink" title="标准盒模型与怪异盒模型的表现效果的区别之处"></a>标准盒模型与怪异盒模型的表现效果的区别之处</h3><ul><li>标准盒模型的盒子大小 = content + border + padding + margin </li><li>怪异盒模型的盒子大小 = width(content + border + padding) + margin</li></ul><h3 id="可以通过属性box-sizing-来设置盒子模型的解析模式"><a href="#可以通过属性box-sizing-来设置盒子模型的解析模式" class="headerlink" title="可以通过属性box-sizing 来设置盒子模型的解析模式"></a>可以通过属性box-sizing 来设置盒子模型的解析模式</h3><ul><li>box-sizing: content-box; (默认值),border和padding不算在宽度内<br>是W3C的标准模型 总宽 = width + padding + border + margin</li><li>box-sizing: border-box; border和padding计算在宽度里，可以理解是怪异模型<br>总宽 = width + margin</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;盒子模型可以用来对元素进行布局，包括内边距，边框，外边距和实际内容&quot;&gt;&lt;a href=&quot;#盒子模型可以用来对元素进行布局，包括内边距，边框，外边距和实际内容&quot; class=&quot;headerlink&quot; title=&quot;盒子模型可以用来对元素进行布局，包括内边距，边框，外</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>三栏布局--双飞翼布局（圣杯布局）</title>
    <link href="http://coderbxd.top/2021/07/03/css02-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80(%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80)/"/>
    <id>http://coderbxd.top/2021/07/03/css02-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80(%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80)/</id>
    <published>2021-07-03T06:09:18.753Z</published>
    <updated>2021-07-03T06:30:35.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="利用定位实现两侧固定中间自适应"><a href="#利用定位实现两侧固定中间自适应" class="headerlink" title="利用定位实现两侧固定中间自适应"></a>利用定位实现两侧固定中间自适应</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.father &#123;</span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.left,.right &#123;</span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">350px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- html 结构 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用flex布局实现两侧固定中间自适应"><a href="#利用flex布局实现两侧固定中间自适应" class="headerlink" title="利用flex布局实现两侧固定中间自适应"></a>利用flex布局实现两侧固定中间自适应</h3><ul><li>父盒子设置display: flex;</li><li>左右盒子设置固定高度</li><li>中间盒子设置固定宽高</li><li>中间盒子设置flex: 1;</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.father &#123;</span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">  <span class="attribute">display</span>: flex;</span></span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line"><span class="css">  <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: blue;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用BFC块级格式化上下文，实现两侧固定中间自适应"><a href="#使用BFC块级格式化上下文，实现两侧固定中间自适应" class="headerlink" title="使用BFC块级格式化上下文，实现两侧固定中间自适应"></a>使用BFC块级格式化上下文，实现两侧固定中间自适应</h3><ul><li>左右固定宽高，进行浮动</li><li>中间 overflow: hidden;</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.father &#123;</span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: pink;</span></span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line"><span class="css">  <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: blue;</span></span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line"><span class="css">  <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: blue;</span></span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line"><span class="css">  <span class="attribute">height</span>: <span class="number">450px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">  <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- html 结构 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- left和right必须在center前面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;利用定位实现两侧固定中间自适应&quot;&gt;&lt;a href=&quot;#利用定位实现两侧固定中间自适应&quot; class=&quot;headerlink&quot; title=&quot;利用定位实现两侧固定中间自适应&quot;&gt;&lt;/a&gt;利用定位实现两侧固定中间自适应&lt;/h3&gt;&lt;figure class=&quot;highli</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>如何实现盒子水平垂直居中</title>
    <link href="http://coderbxd.top/2021/07/03/css01-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <id>http://coderbxd.top/2021/07/03/css01-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</id>
    <published>2021-07-03T05:45:54.566Z</published>
    <updated>2021-07-03T06:05:10.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法一-利用定位"><a href="#方法一-利用定位" class="headerlink" title="方法一 利用定位"></a>方法一 利用定位</h3><ul><li>核心代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .parent &#123;</span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法二-利用margin-auto"><a href="#方法二-利用margin-auto" class="headerlink" title="方法二 利用margin:auto"></a>方法二 利用margin:auto</h3><ul><li>核心代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .parent &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法三-利用display-table-cell"><a href="#方法三-利用display-table-cell" class="headerlink" title="方法三 利用display: table-cell;"></a>方法三 利用display: table-cell;</h3><ul><li>核心代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .parent &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="css">    <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: inline-block</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法四-利用display-flex"><a href="#方法四-利用display-flex" class="headerlink" title="方法四 利用display: flex;"></a>方法四 利用display: flex;</h3><ul><li>核心代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .parent &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">    <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">align-items</span>: center;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="方法五-利用transform"><a href="#方法五-利用transform" class="headerlink" title="方法五 利用transform"></a>方法五 利用transform</h3><ul><li>核心代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .parent &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line"><span class="css">    weight: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span></span><br><span class="line"><span class="css">    <span class="comment">/* 不用计算宽高 */</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;方法一-利用定位&quot;&gt;&lt;a href=&quot;#方法一-利用定位&quot; class=&quot;headerlink&quot; title=&quot;方法一 利用定位&quot;&gt;&lt;/a&gt;方法一 利用定位&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;核心代码&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="CSS" scheme="http://coderbxd.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器输入网址到页面渲染全过程</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A807-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A807-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%85%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2021-07-02T07:15:28.371Z</published>
    <updated>2021-07-02T07:16:41.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="输入URL到页面加载显示完成发生了什么"><a href="#输入URL到页面加载显示完成发生了什么" class="headerlink" title="输入URL到页面加载显示完成发生了什么"></a>输入URL到页面加载显示完成发生了什么</h3><ul><li><p>DNS解析</p></li><li><p>TCP连接</p></li><li><p>发送HTTP请求</p></li><li><p>服务器处理请求并返回HTTP报文</p></li><li><p>浏览器解析渲染页面</p></li><li><p>连接结束</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;输入URL到页面加载显示完成发生了什么&quot;&gt;&lt;a href=&quot;#输入URL到页面加载显示完成发生了什么&quot; class=&quot;headerlink&quot; title=&quot;输入URL到页面加载显示完成发生了什么&quot;&gt;&lt;/a&gt;输入URL到页面加载显示完成发生了什么&lt;/h3&gt;&lt;ul&gt;
</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>csrf和xss</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A806-xss%E5%92%8Ccsrf/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A806-xss%E5%92%8Ccsrf/</id>
    <published>2021-07-02T07:11:19.095Z</published>
    <updated>2021-07-02T07:14:34.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="csrf和xss的网络攻击及防范"><a href="#csrf和xss的网络攻击及防范" class="headerlink" title="csrf和xss的网络攻击及防范"></a>csrf和xss的网络攻击及防范</h3><ul><li><p>CSRF：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求，比如用户登录了一个网站后，立刻在另一个ｔａｂ页面访问量攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库</p><ul><li>防御CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</li></ul></li><li><p>XSS：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在url地址的请求参数中  </p><ul><li>防御xss cookie设置httpOnly属性，对用户的输入进行检查，进行特殊字符过滤</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;csrf和xss的网络攻击及防范&quot;&gt;&lt;a href=&quot;#csrf和xss的网络攻击及防范&quot; class=&quot;headerlink&quot; title=&quot;csrf和xss的网络攻击及防范&quot;&gt;&lt;/a&gt;csrf和xss的网络攻击及防范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CSRF：</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>HTML5新增属性</title>
    <link href="http://coderbxd.top/2021/07/02/html01-HTML5%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7/"/>
    <id>http://coderbxd.top/2021/07/02/html01-HTML5%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7/</id>
    <published>2021-07-02T07:07:43.079Z</published>
    <updated>2021-07-02T07:09:00.407Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML5新增元素"><a href="#HTML5新增元素" class="headerlink" title="HTML5新增元素"></a>HTML5新增元素</h3><ul><li><p>首先html5为了更好的实践web语义化，增加了header，footer，nav,aside,section等语义化标签</p></li><li><p>在表单方面，为了增强表单，为input增加了color，emial,data ,range等类型</p></li><li><p>在存储方面，提供了sessionStorage，localStorage,和离线存储，通过这些存储方式方便数据在客户端的存储和获取</p></li><li><p>在多媒体方面规定了音频和视频元素audio和vedio，另外还有地理定位，canvas画布，拖放，多线程编程的web worker和websocket协议</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HTML5新增元素&quot;&gt;&lt;a href=&quot;#HTML5新增元素&quot; class=&quot;headerlink&quot; title=&quot;HTML5新增元素&quot;&gt;&lt;/a&gt;HTML5新增元素&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先html5为了更好的实践web语义化，增加了header，fo</summary>
      
    
    
    
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
    <category term="HTML" scheme="http://coderbxd.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>http2.0新特性</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A805-http2.0%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A805-http2.0%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-07-02T07:05:16.096Z</published>
    <updated>2021-07-02T07:06:45.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="http2-0的特性如下"><a href="#http2-0的特性如下" class="headerlink" title="http2.0的特性如下"></a>http2.0的特性如下</h3><ul><li><p>内容安全，应为http2.0是基于https的，天然具有安全特性，通过http2.0的特性可以避免单纯使用https的性能下降</p></li><li><p>二进制格式，http1.X的解析是基于文本的，http2.0将所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式编码，基于二进制可以让协议有更多的扩展性，比如引入了帧来传输数据和指令</p></li><li><p>多路复用，这个功能相当于是长连接的增强，每个request请求可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面，另外多路复用中也支持了流的优先级，允许客户端告诉服务器那些内容是更优先级的资源，可以优先传输，</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;http2-0的特性如下&quot;&gt;&lt;a href=&quot;#http2-0的特性如下&quot; class=&quot;headerlink&quot; title=&quot;http2.0的特性如下&quot;&gt;&lt;/a&gt;http2.0的特性如下&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;内容安全，应为http2.0是基于http</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>http返回的状态码</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A804-http%E8%BF%94%E5%9B%9E%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%97/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A804-http%E8%BF%94%E5%9B%9E%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%97/</id>
    <published>2021-07-02T06:50:44.955Z</published>
    <updated>2021-07-02T06:55:47.998Z</updated>
    
    <content type="html"><![CDATA[<h3 id="状态码大全"><a href="#状态码大全" class="headerlink" title="状态码大全"></a>状态码大全</h3><ul><li><p>100    Continue    继续。客户端应继续其请求</p></li><li><p>101    Switching Protocols    切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，+ 例如，切换到HTTP的新版本协议</p></li><li><p>200    OK    请求成功。一般用于GET与POST请求</p></li><li><p>201    Created    已创建。成功请求并创建了新的资源</p></li><li><p>202    Accepted    已接受。已经接受请求，但未处理完成</p></li><li><p>203    Non-Authoritative Information    非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</p></li><li><p>204    No Content    无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</p></li><li><p>205    Reset Content    重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单</p></li><li><p>206    Partial Content    部分内容。服务器成功处理了部分GET请求</p></li><li><p>300    Multiple Choices    多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</p></li><li><p>301    Moved Permanently    永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</p></li><li><p>302    Found    临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</p></li><li><p>303    See Other    查看其它地址。与301类似。使用GET和POST请求查看</p></li><li><p>304    Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p></li><li><p>305    Use Proxy    使用代理。所请求的资源必须通过代理访问</p></li><li><p>306    Unused    已经被废弃的HTTP状态码</p></li><li><p>307    Temporary Redirect    临时重定向。与302类似。使用GET请求重定向</p></li><li><p>400    Bad Request    客户端请求的语法错误，服务器无法理解</p></li><li><p>401    Unauthorized    请求要求用户的身份认证</p></li><li><p>402    Payment Required    保留，将来使用</p></li><li><p>403    Forbidden    服务器理解请求客户端的请求，但是拒绝执行此请求</p></li><li><p>404    Not Found    服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</p></li><li><p>405    Method Not Allowed    客户端请求中的方法被禁止</p></li><li><p>406    Not Acceptable    服务器无法根据客户端请求的内容特性完成请求</p></li><li><p>407    Proxy Authentication Required    请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</p></li><li><p>408    Request Time-out    服务器等待客户端发送的请求时间过长，超时</p></li><li><p>409    Conflict    服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</p></li><li><p>410    Gone    客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</p></li><li><p>411    Length Required    服务器无法处理客户端发送的不带Content-Length的请求信息</p></li><li><p>412    Precondition Failed    客户端请求信息的先决条件错误</p></li><li><p>413    Request Entity Too Large    由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</p></li><li><p>414    Request-URI Too Large    请求的URI过长（URI通常为网址），服务器无法处理</p></li><li><p>415    Unsupported Media Type    服务器无法处理请求附带的媒体格式</p></li><li><p>416    Requested range not satisfiable    客户端请求的范围无效</p></li><li><p>417    Expectation Failed    服务器无法满足Expect的请求头信息</p></li><li><p>500    Internal Server Error    服务器内部错误，无法完成请求</p></li><li><p>501    Not Implemented    服务器不支持请求的功能，无法完成请求</p></li><li><p>502    Bad Gateway    作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</p></li><li><p>503    Service Unavailable    由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</p></li><li><p>504    Gateway Time-out    充当网关或代理的服务器，未及时从远端服务器获取请求</p></li><li><p>505    HTTP Version not supported    服务器不支持请求的HTTP协议的版本，无法完成处理</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;状态码大全&quot;&gt;&lt;a href=&quot;#状态码大全&quot; class=&quot;headerlink&quot; title=&quot;状态码大全&quot;&gt;&lt;/a&gt;状态码大全&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;100    Continue    继续。客户端应继续其请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>cookie、session的区别</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A803-cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A803-cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-02T06:48:08.117Z</published>
    <updated>2021-07-02T06:49:35.453Z</updated>
    
    <content type="html"><![CDATA[<h3 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h3><ul><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>考虑到安全应当使用session。</li><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>考虑到减轻服务器性能方面，应当使用COOKIE。</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;cookie和session&quot;&gt;&lt;a href=&quot;#cookie和session&quot; class=&quot;headerlink&quot; title=&quot;cookie和session&quot;&gt;&lt;/a&gt;cookie和session&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;cookie数据存放在客户的浏览</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>http和https</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A802-http%E5%92%8Chttps/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A802-http%E5%92%8Chttps/</id>
    <published>2021-07-02T06:27:07.466Z</published>
    <updated>2021-07-02T06:32:07.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="http和https的基本概念"><a href="#http和https的基本概念" class="headerlink" title="http和https的基本概念"></a>http和https的基本概念</h3><ul><li><p>https的SSL加密是在传输层实现的。</p></li><li><p>http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p></li><li><p>https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p></li><li><p>https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p></li></ul><h3 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h3><ul><li><p>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</p></li><li><p>主要的区别如下：</p><ul><li><p>Https协议需要ca证书，费用较高。</p></li><li><p>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p></li><li><p>使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443</p></li><li><p>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p></li></ul></li></ul><h3 id="https协议的工作原理"><a href="#https协议的工作原理" class="headerlink" title="https协议的工作原理"></a>https协议的工作原理</h3><ul><li><p>客户使用https url访问服务器，则要求web 服务器建立ssl链接。</p></li><li><p>web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。</p></li><li><p>客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。</p></li><li><p>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</p></li><li><p>web服务器通过自己的私钥解密出会话密钥。</p></li><li><p>web服务器通过会话密钥加密与客户端之间的通信。</p></li></ul><h3 id="https协议的优点"><a href="#https协议的优点" class="headerlink" title="https协议的优点"></a>https协议的优点</h3><ul><li><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></li><li><p>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p></li><li><p>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p></li><li><p>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p></li></ul><h3 id="https协议的缺点"><a href="#https协议的缺点" class="headerlink" title="https协议的缺点"></a>https协议的缺点</h3><ul><li><p>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</p></li><li><p>https缓存不如http高效，会增加数据开销。</p></li><li><p>SSL证书也需要钱，功能越强大的证书费用越高。</p></li><li><p>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;http和https的基本概念&quot;&gt;&lt;a href=&quot;#http和https的基本概念&quot; class=&quot;headerlink&quot; title=&quot;http和https的基本概念&quot;&gt;&lt;/a&gt;http和https的基本概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;https的SSL</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>cookie、sessionStorage、localStorage的区别</title>
    <link href="http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A801-cookie%E3%80%81sessionStorage%E3%80%81localStorage%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://coderbxd.top/2021/07/02/%E6%B5%8F%E8%A7%88%E5%99%A801-cookie%E3%80%81sessionStorage%E3%80%81localStorage%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-02T05:54:26.358Z</published>
    <updated>2021-07-02T06:34:23.700Z</updated>
    
    <content type="html"><![CDATA[<h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ul><li>都是保存在浏览器端，并且是同源的。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>cookie：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约4K左右）。</li><li>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）。</li><li>localStorage：localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）。</li></ul><h3 id="cookie的作用"><a href="#cookie的作用" class="headerlink" title="cookie的作用"></a>cookie的作用</h3><ul><li>保存用户登录状态<ul><li>例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。</li></ul></li><li>跟踪用户行为<ul><li>例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;共同点&quot;&gt;&lt;a href=&quot;#共同点&quot; class=&quot;headerlink&quot; title=&quot;共同点&quot;&gt;&lt;/a&gt;共同点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;都是保存在浏览器端，并且是同源的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class</summary>
      
    
    
    
    
    <category term="浏览器" scheme="http://coderbxd.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>18-Vue响应式原理</title>
    <link href="http://coderbxd.top/2021/06/19/23-Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://coderbxd.top/2021/06/19/23-Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-19T07:04:16.276Z</published>
    <updated>2021-07-02T06:15:58.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue是如何实现响应式的"><a href="#Vue是如何实现响应式的" class="headerlink" title="Vue是如何实现响应式的"></a>Vue是如何实现响应式的</h3><ul><li>Vue实现响应式要了解两个核心<ul><li>第一个: Vue如何监听data数据的改变</li><li>第二个: data数据改变的时候, Vue如何知道应该修改哪一个使用了data数据的元素</li></ul></li></ul><h3 id="Vue如何监听data数据的改变"><a href="#Vue如何监听data数据的改变" class="headerlink" title="Vue如何监听data数据的改变"></a>Vue如何监听data数据的改变</h3><ul><li>实质上vue是通过 defineProperty 方法来监听data数据的改变的</li><li>defineProperty方法需要传入三个参数<ul><li>第一个参数是需要监听的对象(目标对象)</li><li>第二个参数是监听对象的值(引用的目标对象上的字符串键属性)</li><li>第三个参数是一个对象, 对象中编写对应事件</li></ul></li></ul><h3 id="data数据改变的时候-Vue如何知道应该修改哪一个使用了data数据的元素"><a href="#data数据改变的时候-Vue如何知道应该修改哪一个使用了data数据的元素" class="headerlink" title="data数据改变的时候, Vue如何知道应该修改哪一个使用了data数据的元素"></a>data数据改变的时候, Vue如何知道应该修改哪一个使用了data数据的元素</h3><ul><li>vue是通过一种名叫 “发布者订阅者” 的模式来知道当data数据修改的时候, 应该修改哪一个使用了data数据的元素的</li></ul><h3 id="代码简单模拟vue的响应式原理"><a href="#代码简单模拟vue的响应式原理" class="headerlink" title="代码简单模拟vue的响应式原理"></a>代码简单模拟vue的响应式原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是简单地模拟一下vue的响应式原理</span></span><br><span class="line"><span class="comment">// vue实现响应式核心为两个</span></span><br><span class="line"><span class="comment">// 第一个: vue如何监听data数据的更改</span></span><br><span class="line"><span class="comment">// 第二个: vue如何知道应该修改页面中的哪个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先来解决第一个问题</span></span><br><span class="line"><span class="comment">// 实质上vue是通过defineProperty方法来监听数据的更改的</span></span><br><span class="line"><span class="comment">// 比如这里的obj对象就是vue中的data对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;xiaolam&quot;</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue中会获得这个obj对象, 然后遍历里面的键</span></span><br><span class="line"><span class="comment">// 通过 Object.keys(obj) 来获取obj中的键并组成一个数组</span></span><br><span class="line"><span class="comment">// 然后通过forEach 遍历这个数组, 给数组中的键通过defineProperty方法监听里面的所有key</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value = obj[key];</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="comment">// 通过defineProperty中的set方法就可以监听obj对象中数据的更改了</span></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;进入defineProperty中的set&quot;</span>);</span><br><span class="line">      <span class="comment">// 在更改obj中的数据的时候, 调用发布者中的notify方法, 这个方法会调用所有订阅者中的update方法</span></span><br><span class="line">      <span class="comment">// 而update方法里面可以编写更新页面的代码</span></span><br><span class="line">      dep.notify()</span><br><span class="line">      value = newValue</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 通过defineProperty中的get方法就可以监听页面中什么元素的通过mustache语法取用obj数据</span></span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;进入defineProperty中的get&quot;</span>);</span><br><span class="line">      <span class="comment">// 在使用obj的数据后, 将使用数据的元素做一个记录</span></span><br><span class="line">      <span class="comment">// 存储在发布者中</span></span><br><span class="line">      <span class="keyword">const</span> w1 = <span class="keyword">new</span> Watcher(<span class="string">&quot;w1&quot;</span>)</span><br><span class="line">      dep.addSub(w1)</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过上面的过程就可以实现第一个问题: vue如何实现监听data数据的更改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在解决第二个问题: vue如何知道应该修改页面中的哪个元素</span></span><br><span class="line"><span class="comment">// 实质上vue使用的是一个 发布者订阅者 的技术</span></span><br><span class="line"><span class="comment">// 发布者就是指vue实例</span></span><br><span class="line"><span class="comment">// 而订阅者就是指使用mustache语法的元素</span></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个数组用于存储订阅者</span></span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 在元素取用data数据的时候调用Dep中的这个方法, 来将元素(订阅者)加入到subs数组中用于记录订阅者都有谁</span></span><br><span class="line">  <span class="function"><span class="title">addSub</span>(<span class="params">watcher</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(watcher)</span><br><span class="line">  &#125;; </span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里做更新页面的操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;更新&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br></pre></td></tr></table></figure><ul><li>思路为: 订阅者和发布者是两个类, 在项目运行的时候, 就new对应的data属性发布者出来(一个data属性对应一个发布者), 在当有页面元素使用了data数据的时候, 触发了defineProperty中的get, 在get中new一个对应的订阅者出来, 并把这个订阅者通过对应发布者中的addSub方法记录在发布者中, 在data数据中某个属性发生改变的时候, 触发defineProperty中的set方法, 在set方法中调用对应发布者的notify方法, 这个方法会调用其中的每个订阅者中的update方法, 在update方法中就编写更新页面的操作, 就是这样发布者就知道应该让哪个订阅者更新自身的展示数据了, 从而实现响应式</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Vue是如何实现响应式的&quot;&gt;&lt;a href=&quot;#Vue是如何实现响应式的&quot; class=&quot;headerlink&quot; title=&quot;Vue是如何实现响应式的&quot;&gt;&lt;/a&gt;Vue是如何实现响应式的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Vue实现响应式要了解两个核心&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="VUE" scheme="http://coderbxd.top/tags/VUE/"/>
    
    <category term="面试高频" scheme="http://coderbxd.top/tags/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>17-axios网络请求</title>
    <link href="http://coderbxd.top/2021/06/19/18-Vue-axios%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85/"/>
    <id>http://coderbxd.top/2021/06/19/18-Vue-axios%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85/</id>
    <published>2021-06-19T07:04:16.269Z</published>
    <updated>2021-07-02T06:24:04.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常见的网络请求模块-以及它们的优缺点对比"><a href="#常见的网络请求模块-以及它们的优缺点对比" class="headerlink" title="常见的网络请求模块, 以及它们的优缺点对比"></a>常见的网络请求模块, 以及它们的优缺点对比</h3><ul><li>传统Ajax请求<ul><li>缺点: 配置和调用方式等非常混乱</li><li>真实开发中真的很少直接使用, 而是使用Jquery-Ajax</li></ul></li><li>Jquery-ajax<ul><li>相对于传统的Ajax非常好用</li><li>但是我们在整个vue的开发中都是不需要使用Jquery的</li><li>那么就意味着为了方便我们进行一个网络请求, 特意引用了一个jQuery, 这显然不合理, Vue的代码才一万多行, jQuery的代码就一万多行了</li><li>完全没有必要为了使用网络请求就引用jQuery这个框架</li></ul></li><li>官方在Vue1.x的时候, 推出了Vue-resource<ul><li>Vue-resource的体积相对于jQuery小很多</li><li>而且Vue-resource是Vue官方推出的</li><li>但是在Vue2.0以后, Vue-resource就不再更新了</li><li>这就意味着如果继续使用Vue-resource的话对项目的开发和维护都存在很大的隐患</li></ul></li><li>axios<ul><li>在尤雨溪宣布不再更新vue-resource的时候, 推荐使用axios</li><li>所以就选axios了</li><li>vue作者都让你选这个了, 你还想啥呢?</li><li>可能你会说, 尤雨溪只是个写轮子的, 他懂个P的vue(/滑稽)</li></ul></li></ul><h3 id="axios的基本使用"><a href="#axios的基本使用" class="headerlink" title="axios的基本使用"></a>axios的基本使用</h3><ul><li>安装axios 在项目根目录下, 命令行输入<ul><li>npm install axios –save (运行时依赖)</li></ul></li><li>导入axios, 直接通过 axios() 使用, 并不需要使用Vue.use(axios) 来install, 因为axios本身并不是vue中的模块, vue并不具有axios的install方法</li><li>axios支持多种请求方式<ul><li>axios(config)</li><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]])</li></ul></li><li>但是我们一般使用第一个 axios(config) 因为这个灵活, 可以在config里面设置请求方式</li><li>axios的特点: axios() 在网络请求完成后会返回一个Promise对象, 所以我们可以在axios() 后直接使用then() 和catch() </li><li>请看下列代码实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios 是不需要使用 Vue.use() 方法, 因为axios并不是vue中的模块</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// axios有很多种请求方式, 默认的请求方式为get请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  <span class="comment">// 提问这里为什么没有跨域问题?</span></span><br><span class="line">  <span class="comment">// 因为在后端已经处理过跨域了</span></span><br><span class="line">  url : <span class="string">&quot;请求的url&quot;</span>,</span><br><span class="line">  <span class="comment">// 可以通过 method 属性来指定请求方式</span></span><br><span class="line">  method : <span class="string">&quot;post&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果使用get请求的话, 如果带有参数的话, 需要拼接到url上, 这样会导致url很长, 所以axios提供了一个parmas对象, 用于参数的拼接</span></span><br><span class="line">  params : &#123;</span><br><span class="line">    type : <span class="string">&quot;pop&quot;</span>,</span><br><span class="line">    page : <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// axios 在网络请求操作完成之后会返回一个 new Promise 对象, 所以这里可以使用then 和catch</span></span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios处理并发请求"><a href="#axios处理并发请求" class="headerlink" title="axios处理并发请求"></a>axios处理并发请求</h3><ul><li>如果我们需要多个axios请求完成后, 再进行下一步的操作</li><li>axios提供了一个 axios.all() 方法, 用于处理这种需求</li><li>这个方法里面传入一个数组, 数组中传入axios请求</li><li>在axios请求都完成后, axios.all() 方法会调用then(), then()中传入一个函数, 函数中有一个result参数</li><li>result是一个数组, 数组中第一个数据即是第一个axios请求返回的数据, 依此类推</li><li>如果想要将各个返回的数据分开的话, then() 中还可以传入一个 axios.spread() 方法, 方法中传入一个函数</li><li>该函数的参数就是对应的axios请求返回的数据</li><li>看以下实例代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios处理并发请求</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line">axios.all([</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url : <span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url : <span class="string">&quot;http://152.136.185.210:8000/api/w6/home/data&quot;</span>,</span><br><span class="line">    params : &#123;</span><br><span class="line">      type : <span class="string">&quot;pop&quot;</span>,</span><br><span class="line">      page : <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">])</span><br><span class="line"><span class="comment">/* .then((result =&gt; &#123;</span></span><br><span class="line"><span class="comment">  // 这里的result是一个数组, 里面按顺序存放了各个axios请求返回的数据</span></span><br><span class="line"><span class="comment">  console.log(result);</span></span><br><span class="line"><span class="comment">  console.log(result[0]);</span></span><br><span class="line"><span class="comment">  console.log(result[1]);</span></span><br><span class="line"><span class="comment">&#125;)) */</span></span><br><span class="line">.then(axios.spread(<span class="function">(<span class="params">res1, res2</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 axios.spread() 将各个axios请求返回的数据, 分开</span></span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios设置全局配置信息"><a href="#axios设置全局配置信息" class="headerlink" title="axios设置全局配置信息"></a>axios设置全局配置信息</h3><ul><li>其实我们的请求中有很多东西都是相同的, 比如url中的baseURL, 和设置的请求超时时间等等</li><li>如果我们每次请求都要重写这些config, 这样代码就很重复了</li><li>所以我们会将固定的参数抽取出来</li><li>axios提供了一个 defaults 对象用于进行全局配置</li><li>看以下代码实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line">axios.defaults.baseURL = <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span> <span class="comment">// 这里设置了baseURL</span></span><br><span class="line">axios.defaults.timeout = <span class="number">5000</span>  <span class="comment">// 这里设置了请求超时时间</span></span><br><span class="line">axios.all([</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url : <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url : <span class="string">&quot;/home/data&quot;</span>,</span><br><span class="line">    params : &#123;</span><br><span class="line">      type :<span class="string">&quot;pop&quot;</span>,</span><br><span class="line">      page : <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 axios.spread() 将各个axios请求返回的数据, 分开</span></span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="常见的axios配置项"><a href="#常见的axios配置项" class="headerlink" title="常见的axios配置项"></a>常见的axios配置项</h3><ul><li>请求地址<ul><li>url: ‘/user’,</li></ul></li><li>请求类型<ul><li>method: ‘get’,</li></ul></li><li>请根路径<ul><li>baseURL: ‘<a href="http://www.mt.com/api&#39;">http://www.mt.com/api&#39;</a>,</li></ul></li><li>请求前的数据处理<ul><li>transformRequest:[function(data){}],</li></ul></li><li>请求后的数据处理<ul><li>transformResponse: [function(data){}],</li></ul></li><li>自定义的请求头<ul><li>headers:{‘x-Requested-With’:’XMLHttpRequest’},</li></ul></li><li>URL查询对象 (注意只有get请求方式才用params)<ul><li>params:{ id: 12 }</li></ul></li><li>查询对象序列化函数<ul><li>paramsSerializer: function(params){ }</li></ul></li><li>request body (注意只用post请求方式才用这个)<ul><li>data: { key: ‘aa’},</li></ul></li><li>超时设置s<ul><li>timeout: 1000,</li></ul></li><li>跨域是否带Token<ul><li>withCredentials: false,</li></ul></li><li>自定义请求处理<ul><li>adapter: function(resolve, reject, config){},</li></ul></li><li>身份验证信息<ul><li>auth: { uname: ‘’, pwd: ‘12’},</li></ul></li><li>响应的数据格式 json / blob /document /arraybuffer / text / + stream<ul><li>responseType: ‘json’,</li></ul></li></ul><h3 id="创建axios实例"><a href="#创建axios实例" class="headerlink" title="创建axios实例"></a>创建axios实例</h3><ul><li>在实际开发中, 很有可能会遇到这种状况</li><li>网络请求的baseURL是不一样的, 或者说不同的网络请求设置的请求超时时间是不一样的</li><li>这个时候, 如果我们还是使用全局配置的 axios.default 就无法正确地请求正确的数据了</li><li>所以我们要创建axios实例</li><li>创建axios实例, 通过axios.create创建</li><li>看以下代码实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如这里的网络请求, 需要设置的请求超时时间为 5000毫秒</span></span><br><span class="line"><span class="keyword">const</span> instans1 = axios.create(&#123;</span><br><span class="line">  <span class="comment">// 在这里设置配置</span></span><br><span class="line">  baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span>,</span><br><span class="line">  timeout : <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在这里使用axios实例</span></span><br><span class="line"><span class="comment">// 与全局中使用axios基本一致</span></span><br><span class="line">instans1(&#123;</span><br><span class="line">  url : <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如这里需要设置请求超时时间为10000</span></span><br><span class="line"><span class="keyword">const</span> instans2 = axios.create(&#123;</span><br><span class="line">  baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span>,</span><br><span class="line">  timeout : <span class="number">10000</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在这里使用instans2进行网络请求</span></span><br><span class="line">instans2(&#123;</span><br><span class="line">  url : <span class="string">&quot;/home/data&quot;</span>,</span><br><span class="line">  params : &#123;</span><br><span class="line">    type :<span class="string">&quot;pop&quot;</span>,</span><br><span class="line">    page : <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h3><ul><li>如果我们没有把axios封装到一个文件中, 而是在需要用到axios的组件中都引用axios</li><li>那么如果在未来的某一天, axios突然宣布不再更新</li><li>那我们的项目想要使用另外的替代品将会变得十分困难, 因为我们每个组件都依赖了axios</li><li>为了降低我们各个组件对axios的依赖性</li><li>我们要将axios封装在一个独立的文件中</li><li>封装过程及引用方法请看下列示例代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文件 src/network/request.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios实例并导出</span></span><br><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span>,</span><br><span class="line">    timeout : <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  instans(config)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如何使用</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url : <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过组件传入一个函数, 然后回调这个函数返回数据给组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config,success,error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  instans(config)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    success(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    error(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如何使用</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span></span><br><span class="line">request(</span><br><span class="line">  &#123;</span><br><span class="line">    url: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="built_in">this</span>.res = res;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 通过组件传入一个函数, 然后回调这个函数返回数据给组件的另外一种形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  instans(config.baseConfig)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    config.success(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    config.error(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">request(&#123;</span><br><span class="line">  baseConfig: &#123;</span><br><span class="line">    url: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 实际上, 我们并不会使用以上的两种方法, 而是使用 Promise来返回数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    instans(config)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">request(&#123;</span><br><span class="line">    url: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.res = res;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1 实际上, 我们也不会像上面那样, 因为axios本身就返回一个Promise, 没有必要再包一层</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> instans(config)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.res = res;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="axios拦截器的使用"><a href="#axios拦截器的使用" class="headerlink" title="axios拦截器的使用"></a>axios拦截器的使用</h3><ul><li>axios提供了拦截器, 用于我们再发送每次请求或者得到相应数据后, 进行对应的处理</li><li>拦截器分为: 请求拦截器 interceptors.request 和 响应拦截器 interceptors.response</li><li>请求拦截器主要用法<ul><li>1.当发送网络请求的时候, 在页面中添加一个loading组件, 作为动画</li><li>2.某些请求是要求用户必须登陆的, 这是请求拦截器就可以判断请求是否带有token(令牌), 如果没有token就跳转到login页面</li><li>3.对请求的参数进行序列化, 就是对请求的参数做一些修改或者添加一些参数</li></ul></li><li>响应拦截器主要用法<ul><li>1.响应的成功拦截中,主要是对数据进行过滤</li><li>2.响应失败的拦截中, 跨域根据status判断报错的错误码, 跳转到不同的错误提示页面</li></ul></li><li>拦截器使用注意事项, 使用拦截器后, 一定要将数据 return 出去, 否则, 拦截器会把数据拦截住</li><li>基本使用方法看下列代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    baseURL : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 使用拦截器</span></span><br><span class="line">  <span class="comment">// 请求拦截器</span></span><br><span class="line">  instans.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(config);</span><br><span class="line">    <span class="keyword">return</span> config  <span class="comment">// 将数据在return出去</span></span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应拦截器</span></span><br><span class="line">  instans.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> res.data  <span class="comment">// 将数据进行过滤, 只返回data</span></span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送真实的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> instans(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;常见的网络请求模块-以及它们的优缺点对比&quot;&gt;&lt;a href=&quot;#常见的网络请求模块-以及它们的优缺点对比&quot; class=&quot;headerlink&quot; title=&quot;常见的网络请求模块, 以及它们的优缺点对比&quot;&gt;&lt;/a&gt;常见的网络请求模块, 以及它们的优缺点对比&lt;/h3</summary>
      
    
    
    
    
    <category term="VUE" scheme="http://coderbxd.top/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>16-Vuex状态管理</title>
    <link href="http://coderbxd.top/2021/06/19/17-Vue-vuex%E8%AF%A6%E8%A7%A3/"/>
    <id>http://coderbxd.top/2021/06/19/17-Vue-vuex%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-06-19T07:04:16.264Z</published>
    <updated>2021-07-02T06:24:05.895Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是vuex"><a href="#什么是vuex" class="headerlink" title="什么是vuex"></a>什么是vuex</h3><ul><li>官方解释: Vuex是一个专门为Vue.js 应用程序开发的状态管理模式<ul><li>采用集中式存储管理应用的所有组件的状态, 并以相应的规则保证状态以一种可以预测的方式发生变化</li><li>Vuex 也继承到Vue官方调试工具 devtools extension, 提供了诸如零配置的 time-travel 调试 状态快照导入导出等高级调试功能</li></ul></li><li>官方解释其实有点晦涩难懂<ul><li>状态管理模式, 集中式存储管理其实</li><li>就是将需要多个组件共享的变量存储在一个对象中</li><li>然后将这个对象放在顶层的Vue实例中,让其他组件也可以使用</li><li>而且这个对象是响应式的, 这个优点是最牛逼的优点</li></ul></li><li>什么状态需要我们在多个组件间共享呢?<ul><li>用户的登陆状态,用户名称,头像,地理位置信息等等</li><li>商品的收藏,购物车中的物品<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以尝试一下自己写一下这个共享的对象</span></span><br><span class="line"><span class="comment">// 通过将数据集成在一个共享对象中, 然后将这个对象加入到Vue.prototype 原型对象中, 可以做到将对象中的数据共享出去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用给Vue.prototype Vue的原型对象添加一个对象来达到所有组件都可以访问这个对象</span></span><br><span class="line"><span class="keyword">const</span> shareObj = &#123;</span><br><span class="line">  name : <span class="string">&quot;xiaoLam&quot;</span>,</span><br><span class="line">  age : <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype.shareObj = shareObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是有一个问题, 这个共享对象不是响应式的, 所以我说vuex的共享数据是响应式的是最牛逼的优点</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="vuex基本使用"><a href="#vuex基本使用" class="headerlink" title="vuex基本使用"></a>vuex基本使用</h3><ul><li>vuex的安装<ul><li>在项目根目录下命令行输入 npm install vuex –save (运行时依赖安装)</li></ul></li><li>不建议在main.js中使用vuex</li><li>在项目目录下创建一个叫 store的文件夹, 里面创建一个名为 index.js 的文件, 在这个文件中编写vuex的代码</li><li>vuex插件基本使用 在store/index.js文件中<ul><li>引入 vue 和 vuex 因为vuex是依赖vue的</li><li>执行 Vue.use(Vuex) 执行 Vuex中的 install</li><li>创建Vuex实例: 注意,这里创建的是 Vuex.Store实例</li><li>在实例中创建一个 state对象, 在这个对象中写入想要共享的数据</li><li>导出实例</li></ul></li><li>在组件中使用vuex中的共享数据<ul><li>在main.js 中导入上面的实例</li><li>在根组件中注册store , 这样才可以在所有组件中通过 $store 获得store这个对象</li><li>在组件中使用 $store.state 获得这个包含共享数据的对象</li></ul></li><li>修改vuex中的共享数据<ul><li>其实我们可以通过 $store.state 来修改数据</li><li>但是vue官方不建议这样做</li><li>因为 State -&gt; Vue Components -&gt; Actions -&gt; Mutations -&gt; State 是一个单向循环</li><li>官方推荐做法是 我们通过 Vue Components 去修改 Actions 来修改 Mutations 最终达到修改 State 的目的</li><li>因为我们会需要知道是哪一个组件修改了State, 如果直接从 Vue Components 修改State的话就不能追踪是哪个组件修改了State</li><li>Backend API 会监测 Action的改变, Devtools 会监测 Mutations的改变, 按照官方的推荐做法就可以追踪是哪个组件修改了State</li><li>当然也可以跳过Actions, 通过 Vue Components -&gt; Mutations -&gt; State 修改 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是 store/index.js 文件的代码</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步: 引入插件后, 调用Vue.use() 来进行install Vuex</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步: 创建Vuex实例: 注意这里创建的是 Vuex中的Store实例</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state : &#123;</span><br><span class="line">    count : <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步: 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是main.js中的代码</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="comment">// 引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 在根组件中注册 store, 这样就可以在所用组件通过 $store 来获得store这个对象</span></span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用过$store.state 来获得store对象中的state中的共享数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.state.count &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>------------<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;hello-vuex :count=&quot;count&quot; /&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello-vuex</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果向修改vuex中的共享数据, 可以通过 $store.state修改, 但是官方不建议, 不推荐, 不允许这样修改 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后面会讲如何正确地修改vuex中的共享数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.state.count++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.state.count--&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue-devtools-和-mutations"><a href="#vue-devtools-和-mutations" class="headerlink" title="vue-devtools 和 mutations"></a>vue-devtools 和 mutations</h3><ul><li>什么是vuex-devtools<ul><li>这是一个vue官方的浏览器插件, 用于调试vue应用</li><li>这个插件可以用于监控mutations操作</li></ul></li><li>什么是mutations操作<ul><li>其实就是使用同步的操作去修改state共享数据</li></ul></li><li>简单来说, 浏览器插件vuex-devtools可以监控mutations操作, 达到追踪是什么组件修改了state共享数据的效果</li></ul><h3 id="vue-devtools-和-mutations-的使用的注意事项"><a href="#vue-devtools-和-mutations-的使用的注意事项" class="headerlink" title="vue-devtools 和 mutations 的使用的注意事项"></a>vue-devtools 和 mutations 的使用的注意事项</h3><ul><li><p>浏览器安装vue-devtools</p><ul><li>chrome应用商店搜索, vue.js devtools 安装即可</li><li>如果进入不了chrome应用商店, 可以离线下载谷歌访问助手</li><li>安装完成后会在浏览器开发者工具中多了一个”vue”选项卡</li></ul></li><li><p>通过mutations来修改state共享数据</p><ul><li>在 store/index.js 中的Vuex.Store实例中创建 mutations对象</li><li>在对象中编写方法</li><li>mutations中的方法默认会有一个名为state的参数, 这个state就是 state共享数据对象</li><li>定义好方法后, 通过提交的方式来调用方法</li><li>具体看以下代码</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是store/index.js 中的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state : &#123;</span><br><span class="line">    count : <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建mutations 对象</span></span><br><span class="line">  mutations : &#123;</span><br><span class="line">    <span class="comment">// mutations 中的方法中默认会传入一个state的参数, 这个参数就是上面定义的state对象</span></span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是组件中定义的methods</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">addtion</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里并不是直接使用 this.$store.mutation.increment() 来执行increment这个方法</span></span><br><span class="line">    <span class="comment">// 而是用 this.$store.commit(&quot;方法名&quot;) 来提交要使用的方法</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;increment&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">subtraction</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;decrement&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="以上就是Vuex最简单的使用了"><a href="#以上就是Vuex最简单的使用了" class="headerlink" title="以上就是Vuex最简单的使用了"></a>以上就是Vuex最简单的使用了</h3><ul><li>1.提取出一个公共的store对象，用于保存在多个组件中共享的状态</li><li>2.将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到</li><li>3.在其他组件中使用store对象中保存的状态即可<ul><li>通过this.$store.state.属性的方式来访问状态</li><li>通过this.$store.commit(‘mutation中方法’)来修改状态</li></ul></li><li>注意事项：<ul><li>我们通过提交mutation的方式，而非直接改变store.state.count。</li><li>这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。</li></ul></li></ul><h3 id="Vuex的核心概念"><a href="#Vuex的核心概念" class="headerlink" title="Vuex的核心概念"></a>Vuex的核心概念</h3><ul><li>State, Getters, Mutation, Action, Module</li></ul><h3 id="Vuex概念理解-State单一状态树"><a href="#Vuex概念理解-State单一状态树" class="headerlink" title="Vuex概念理解-State单一状态树"></a>Vuex概念理解-State单一状态树</h3><ul><li>Vuex提出单一状态树, 什么是单一状态树呢?<ul><li>单一状态树英文名称为 Single Source of Truth 也可以翻译成单一数据源</li></ul></li><li>简单来说, 就是将所有的数据都放在同一个Store对象中, 不要因为数据的类型不同, 数据量多而分开放</li><li>如果我们将数据保存在多个Store对象中的话, 那么之后的管理和维护等都会变得特别困难</li><li>所以Vuex推荐使用单一状态树来管理应用层级的全部状态</li><li>单一状态树能够让我们用最直接的方式找到某个状态的片段,而且在以后的维护和调试过程中, 也可以非常方便地管理和维护</li><li>总的来说, 就是不要创建多个Store对象, 只创建一个!!! 所有数据, 所有方法, 都放在这个Store对象中</li></ul><h3 id="Vuex核心概念之-getters"><a href="#Vuex核心概念之-getters" class="headerlink" title="Vuex核心概念之 getters"></a>Vuex核心概念之 getters</h3><ul><li>如果我们需要将state中的共享数据经过处理后再将其渲染在页面中的话, 就需要使用 Vuex中的getters对象</li><li>实质上, getters 相当于Vue中的计算属性 computed</li><li>getters的使用<ul><li>在Vue.store实例中定义getters对象</li><li>在getters对象中定义方法</li><li>在getters对象中的方法都具有两个参数, state 和 getters<ul><li>state参数指向state对象</li><li>getters参数指向getters对象</li></ul></li><li>getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</li><li>在组件中通过 $store.getters 来获得这个getters对象</li></ul></li><li>具体使用方法看下列代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是 store/index.js 的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state : &#123;</span><br><span class="line">    count : <span class="number">100</span>,</span><br><span class="line">    students : [</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>, <span class="attr">age</span>:<span class="number">18</span> &#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">112</span>, <span class="attr">name</span>: <span class="string">&quot;suoer&quot;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">113</span>, <span class="attr">name</span>: <span class="string">&quot;yangcong&quot;</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters : &#123;</span><br><span class="line">    <span class="comment">// 在我们需要将共享数据进行处理后再展示在页面的情况下, 就需要使用getters对象, 相当于计算属性computed</span></span><br><span class="line">    <span class="comment">// getters中的方法也是有一个state参数, 指向state对象</span></span><br><span class="line">    <span class="function"><span class="title">powerCount</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 需求1, 过滤state中的students, 取出年龄大于15的</span></span><br><span class="line">    <span class="function"><span class="title">getAge15</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">students</span> =&gt;</span> students.age &gt; <span class="number">15</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 需求2, 获得年龄大于15的student的个数</span></span><br><span class="line">    <span class="function"><span class="title">getAge15Num</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// return state.students.filter(students =&gt; students.age &gt; 15).length</span></span><br><span class="line">      <span class="comment">// getters对象中的方法, 除了state这个参数外, 还有getters参数, 这个参数指向getters对象</span></span><br><span class="line">      <span class="comment">// 所以上面的写法可以写成</span></span><br><span class="line">      <span class="keyword">return</span> getters.getAge15.length</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 需求3, 想要通过用户输入的年龄, 来决定输出大于该年龄的student</span></span><br><span class="line">    <span class="comment">// getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</span></span><br><span class="line">    <span class="comment">// 要达到这个需求的话, 需要在方法中返回一个函数, 具体如下</span></span><br><span class="line">    <span class="comment">// 思路是return出去一个函数, 这个函数有一个形参, 这个形参由用户来决定</span></span><br><span class="line">    <span class="function"><span class="title">getAge</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">students</span> =&gt;</span> students.age &gt; age)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过$store.getters 来获取getters中的数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.powerCount &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.getAge15 &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.getAge15Num &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传入参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.getAge(17) &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Vuex核心概念之-mutations"><a href="#Vuex核心概念之-mutations" class="headerlink" title="Vuex核心概念之 mutations"></a>Vuex核心概念之 mutations</h3><ul><li>Vuex的store状态的更新唯一方式是: 提交 Muattion</li><li>Mutation主要包括两个部分<ul><li>字符串的事件类型(type)</li><li>一个回调函数是(handler), 这个回调函数的第一个参数就是state 指向state对象</li></ul></li><li>mutation的基本使用<ul><li>在 store/index.js 中的Vue.store实例中创建 mutations对象</li><li>这个对象中编写方法</li><li>这个对象中的方法中的第一个参数为 state , 指向state对象</li><li>后面的参数是Vue Components传递过来的额外参数(称为载荷Payload)</li><li>定义好方法后, 在组件中使用 $state.commit(“事件类型”) 提交, 达到更新状态的效果</li><li>具体使用看下列代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些是 store/index.js 中的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state : &#123;</span><br><span class="line">    count : <span class="number">100</span>,</span><br><span class="line">    students : [</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>, <span class="attr">age</span>:<span class="number">18</span> &#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">112</span>, <span class="attr">name</span>: <span class="string">&quot;suoer&quot;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">113</span>, <span class="attr">name</span>: <span class="string">&quot;yangcong&quot;</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建mutations 对象</span></span><br><span class="line">  mutations : &#123;</span><br><span class="line">    <span class="comment">// mutations 中的方法中默认会传入一个state的参数, 这个参数就是上面定义的state对象</span></span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count--</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 如果在mutations更新数据的时候, 携带一些参数的时候</span></span><br><span class="line">    <span class="function"><span class="title">incrementCount</span>(<span class="params">state, count</span>)</span> &#123;</span><br><span class="line">      state.count += count</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 如果参数的个数不是一个的时候, 我们可以传入一个对象</span></span><br><span class="line">    <span class="function"><span class="title">addStudent</span>(<span class="params">state,student</span>)</span> &#123;</span><br><span class="line">      state.students.push(student)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这些是组件中的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果向修改vuex中的共享数据, 可以通过 $store.state修改, 但是官方不建议, 不推荐, 不允许这样修改 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;button @click=&quot;$store.state.count++&quot;&gt;+&lt;/button&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;button @click=&quot;$store.state.count--&quot;&gt;-&lt;/button&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 官方建议这样来修改vuex中的共享数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addtion&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;subtraction&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addCount(5)&quot;</span>&gt;</span>+5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addCount(10)&quot;</span>&gt;</span>+10<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addStudent&quot;</span>&gt;</span>添加学生<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// ..</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// ...</span></span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addtion</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里并不是直接使用 this.$store.mutation.increment() 来执行increment这个方法</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 而是用 this.$store.commit(&quot;方法名&quot;) 来提交要使用的方法</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;increment&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">subtraction</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;decrement&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果带有参数(载荷)， 则在 $store.commit(&quot;事件类型&quot;, 载荷)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$store.commit(&quot;incrementCount&quot;, count);</span></span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="comment">// </span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addStudent</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> student = &#123; <span class="attr">id</span>: <span class="number">115</span>, <span class="attr">name</span>: <span class="string">&quot;wuming&quot;</span>, <span class="attr">age</span>: <span class="number">40</span> &#125;;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果参数不止一个, 载荷也可以是一个对象</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;addStudent&quot;</span>, student);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Mutation提交风格"><a href="#Mutation提交风格" class="headerlink" title="Mutation提交风格"></a>Mutation提交风格</h3><ul><li>上面的通过commit进行提交时一种普通的方式</li><li>Vue还提供了另外一种风格, 它是一个包含type属性的对象</li><li>提交的风格不同, Mutation中的处理方式也会不同<ul><li>普通的提交方式, mutations中的payload就是传入的参数</li><li>包含type属性的对象提交风格, mutations中的payload是整个commit提交的对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 普通的提交风格</span></span><br><span class="line">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;incrementCount&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一个包含type属性的对象提交风格</span></span><br><span class="line">      <span class="built_in">this</span>.$store.commit(&#123;</span><br><span class="line">        type: <span class="string">&quot;incrementCount&quot;</span>, <span class="comment">// type属性, 值为 &quot;事件类型&quot;</span></span><br><span class="line">        count, <span class="comment">// 后面跟的是需要传入的参数</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mutations : &#123;</span><br><span class="line">  <span class="comment">// 如果在mutations更新数据的时候, 携带一些参数的时候</span></span><br><span class="line">  <span class="function"><span class="title">incrementCount</span>(<span class="params">state, count</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 下文的 payload 指 count形参</span></span><br><span class="line">    <span class="comment">// 普通的提交风格接收参数, 这个 payload 就是传入的参数</span></span><br><span class="line">    <span class="comment">// state.count += count</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个包含type属性的对象提交的时候, 这个payload就不是传入的参数了, 而是整个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(count); <span class="comment">// &#123;type: &quot;incrementCount&quot;, count: 5&#125;</span></span><br><span class="line">    <span class="comment">// 要获得传入的参数, 则是 payload.count</span></span><br><span class="line">    state.count += count.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutation的响应式规则"><a href="#Mutation的响应式规则" class="headerlink" title="Mutation的响应式规则"></a>Mutation的响应式规则</h3><ul><li>Vuex的store中的state是响应式的, 当state中的数据发生改变的时候, Vue组件也会跟着自动更新</li><li>如果我们想要使用响应式, 那么我们必须遵守一些Vuex的规则<ul><li>拥有响应式的数据必须提前在state中初始化所需的属性</li></ul></li><li>例如: 如果我们给一个对象添加一个新属性的话, 这个操作不是响应式的, 因为这个新属性没有提前在state中初始化</li><li>又例如: 我们给一个对象删除一个属性, 这个操作也不是响应式的</li><li>那么我们如何让这些操作达到响应式的效果呢?<ul><li>这是要是用 Vue.set() 和 Vue.delete() 这两个方法了<ul><li>Vue.set(要修改的数组或对象, Number/String, 修改后的值)</li><li>Vue.delete(要修改的数组或对象, Number/String)</li></ul></li><li>这两个方法Vue中的内部操作就是, 将要修改的属性添加到 Vue中的响应式系统中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state : &#123;</span><br><span class="line">    info : &#123; <span class="attr">id</span> : <span class="number">102</span>, <span class="attr">name</span> : <span class="string">&quot;fanghuonv&quot;</span>, <span class="attr">age</span> : <span class="number">16</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  mutations : &#123;</span><br><span class="line">    <span class="function"><span class="title">infoUpdate</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 如果给state中的对象属性修改值, 这个操作是响应式的, 因为修改的属性提前在state种初始化了</span></span><br><span class="line">      <span class="comment">// state.info.age = 19;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果给state中的对象添加新的属性, 这个操作不是响应式的, 因为这个新属性并没有提前在state中初始化</span></span><br><span class="line">      <span class="comment">// state.info[&quot;address&quot;] = &quot;jisichang&quot;</span></span><br><span class="line">      <span class="comment">// 如果要想这个操作也变成响应式的话, 就要使用Vue.set(要修改的数组或对象, Number/String, 修改后的值)</span></span><br><span class="line">      <span class="comment">// Vue.set(state.info, &quot;address&quot;, &quot;jisichang&quot;) </span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果给state中的对象删除属性, 这个操作也不是响应式的</span></span><br><span class="line">      <span class="comment">// delete state.info.id;</span></span><br><span class="line">      <span class="comment">// 如果想要这个操作也变成响应式的话, 就要使用Vue.delete(要修改的数组或对象, Number/String)</span></span><br><span class="line">      Vue.delete(state.info, <span class="string">&quot;id&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Vue.set() 和 Vue.delete() 这两个方法内部会将 要修改的属性也一起添加到Vue的响应式系统里面了 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Mutation常量类型"><a href="#Mutation常量类型" class="headerlink" title="Mutation常量类型"></a>Mutation常量类型</h3><ul><li>在mutation中, 我们定义了很多事件类型(也就是其中的方法名称)</li><li>当我们的项目越来越大的时候, Vuex管理的状态越来越多, 需要更新状态的情况也越来越多, 那么就意味着Mutation中的方法越来越多</li><li>方法过多的时候, 使用者需要花费大量的精力去记住这些方法,甚至是多个文件间切换, 查看方法名称, 甚至如果不是复制方法名称的时候, 还有可能出现写错的情况</li><li>那么如何解决上述的问题呢?<ul><li>一种常见的方案就是使用常量替代Mutation事件类型</li><li>我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型都一目了然</li></ul></li><li>具体做法<ul><li>在store文件夹中创建一个名为 mutations-type.js 的文件</li><li>定义mutation方法的时候, 可以使用ES2015中的风格, 使用一个常量来作为函数的名称<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是store/mutations-type.js中的代码</span></span><br><span class="line"><span class="comment">// 在这里定义常量 用于 替代Mutation事件类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">&quot;increment&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT =<span class="string">&quot;decrement&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT_COUNT =<span class="string">&quot;incrementCount&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_STUDENT = <span class="string">&quot;addStudent&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INFO_UPDATE = <span class="string">&quot;infoUpdate&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里是组件中的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 引入定义常量名称的文件</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;</span></span><br><span class="line">  INCREMENT,</span><br><span class="line">  DECREMENT,</span><br><span class="line">  INCREMENT_COUNT,</span><br><span class="line">  ADD_STUDENT,</span><br><span class="line">  INFO_UPDATE,</span><br><span class="line"><span class="javascript">&#125; <span class="keyword">from</span> <span class="string">&quot;./store/mutations-type&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// ...</span></span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addtion</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里就可以直接使用常量名字代替mutation事件类型了</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(INCREMENT);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是 store/index.js 中的文件</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  INCREMENT,</span><br><span class="line">  DECREMENT,</span><br><span class="line">  INCREMENT_COUNT,</span><br><span class="line">  ADD_STUDENT,</span><br><span class="line">  INFO_UPDATE,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./mutations-type&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  mutations : &#123;</span><br><span class="line">    <span class="comment">// 定义mutation方法的时候, 可以使用ES2015中的风格, 使用一个常量来作为函数的名称</span></span><br><span class="line">    [INCREMENT](state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mutation同步函数"><a href="#Mutation同步函数" class="headerlink" title="Mutation同步函数"></a>Mutation同步函数</h3><ul><li>通常情况下, Vuex要求我们的Mutation中的方法必须都是同步方法<ul><li>原因是, 当我们使用devtools时, devtools可以帮助我们捕捉mutation的快照</li><li>但是如果时异步操作的话, devtools就不能追踪这个异步操作是什么时候被完成</li></ul></li><li>所以, 通常情况下, 不能在mutation种进行异步操作</li></ul><h3 id="Action的基本定义"><a href="#Action的基本定义" class="headerlink" title="Action的基本定义"></a>Action的基本定义</h3><ul><li>如果我们需要在Vuex中进行一些异步操作, 比如网络请求</li><li>这个时候我们就要将异步操作在actions中进行</li><li>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的<ul><li>actions中定义方法与在mutation中定义方法的方式基本一样</li><li>要注意的是, actions中的方法中第一个参数不是state 而是 context<ul><li>context 意为 上下文, 指向store 对象</li></ul></li><li>还有一点, 组件中向actions提交事件类型, 并不是通过 commit, 而是通过 dispatch</li></ul></li><li>actions的基本使用<ul><li>注意: 我们不可以直接在actions中通过异步操作直接更新store的状态</li><li>更新store的状态的唯一方式为 mutations</li><li>所以actions中的方法实质上只是一个中转站, 更新store的状态这个操作最终还是要在mutations中进行<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是store/index.js中的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  mutations : &#123;</span><br><span class="line">    [INFO_UPDATE](state) &#123;</span><br><span class="line">      <span class="comment">// actions中的方法最终还是要回到mutations中来更新store的状态</span></span><br><span class="line">      state.info.name = <span class="string">&quot;huixinge&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions : &#123;</span><br><span class="line">    <span class="comment">// 在actions中编写方法, 跟在mutations中编写方法差不多, 但是方法中传入的第一个参数并不是state, 而是 context</span></span><br><span class="line">    <span class="comment">// context意为 上下文, 可以理解为store这个对象</span></span><br><span class="line">    <span class="comment">// 如果想要传入参数, 也是跟mutations中的方法一样, 也是有普通方式, 和传入一个包含type属性的对象方式</span></span><br><span class="line">    [A_INFO_UPDATE](context) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 注意, 不能再actions的方法中更新store的状态, 要记住一点, 更新store状态的唯一方式是mutations中的方法</span></span><br><span class="line">        <span class="comment">// 所以这里做的操作是使用 commit 提交</span></span><br><span class="line">        context.commit(INFO_UPDATE)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求, 需要异步操作完成后, 给组件返回一个信息</span></span><br><span class="line">    <span class="comment">// 第一种方式, 通过组件传参的时候传入一个函数, 在actions中进行异步操作, 异步操作完成后回调这个函数</span></span><br><span class="line">    [A_INFO_UPDATE](context, payload) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 注意, 不能再actions的方法中更新store的状态, 要记住一点, 更新store状态的唯一方式是mutations中的方法</span></span><br><span class="line">        <span class="comment">// 所以这里做的操作是使用 commit 提交</span></span><br><span class="line">        context.commit(INFO_UPDATE)</span><br><span class="line">        <span class="built_in">console</span>.log(payload.message);</span><br><span class="line">        payload.finsh();</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种方式不够优雅, vue官方推荐我们通过 return 一个new Promise 对象来实现</span></span><br><span class="line">    [A_INFO_UPDATE](context, payload) &#123;</span><br><span class="line">      <span class="comment">// 在这里return 出去的是回到组件那里的, 所以组件那里的代码可以用then</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          context.commit(INFO_UPDATE)</span><br><span class="line">          <span class="built_in">console</span>.log(payload.message);</span><br><span class="line">          resolve(<span class="string">&quot;完成了完成了&quot;</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是组件中的代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">aInfoUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 提交给actions 要用 dispatch 而不是commit</span></span><br><span class="line">      <span class="comment">// commit是提交给mutations的</span></span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(A_INFO_UPDATE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第一种方式: 通过传入一个函数, 在异步操作完成后进行回调</span></span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(&#123;</span><br><span class="line">        type: A_INFO_UPDATE,</span><br><span class="line">        message: <span class="string">&quot;你好你好&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">finsh</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;完成了&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第二种方式: 通过 Promise 对象</span></span><br><span class="line">      <span class="built_in">this</span>.$store</span><br><span class="line">        .dispatch(&#123;</span><br><span class="line">          type: A_INFO_UPDATE,</span><br><span class="line">          message: <span class="string">&quot;你好你好&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// actions中return回来的 Promise 是在这里的, 所以这里能用then</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="认识Module"><a href="#认识Module" class="headerlink" title="认识Module"></a>认识Module</h3><ul><li>Module是模块的意思, 为什么在Vuex中我们要使用模块呢?<ul><li>Vue使用单一状态树, 那就意味着很多状态都会交给同一个store管理</li><li>当应用变得非常复杂的时候, store对象就会变得十分臃肿</li><li>为了解决这个问题啊,Vuex允许我们将store分割成模块(Module), 而每个模块都拥有自己的state, mutations, actions, getters</li></ul></li><li>实质就是将共性多的store抽离出去, 这样易于后期维护</li><li>在Module中的 state, mutations, actions, getters 和原来的没有什么区别</li><li>只是有一些需要注意的点<ul><li><ol><li>在组件中想要使用模块中的state共享数据, 通过 $store.state.模块名.数据名 , 来获取</li></ol></li><li><ol start="2"><li>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象.</li></ol></li><li><ol start="3"><li>在actions中的第一个参数里面 可以通过 context.rootState 来获取根的state</li></ol></li><li><ol start="4"><li>在actions中使用 context.commit(“事件类型”) 是提交给模块中的mutations, 而不是根的</li></ol></li><li><ol start="5"><li>在getters的方法中, 拥有第三个参数 rootState, 这个参数指向根的state</li></ol></li><li><ol start="6"><li>其余大多数使用方法与原本的一致</li></ol></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ModuleA = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name : <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    <span class="comment">// 在组件中如果要获取这个name, 则是通过 $store.state.ModuleA.name 来获取</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters : &#123;</span><br><span class="line">    <span class="function"><span class="title">fullName</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.name + <span class="number">111</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullName2</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullName + <span class="number">222</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 除了基本的写法外, 模块中的getters中的函数还有第三个参数, 为 rootState, 指向根的state</span></span><br><span class="line">    <span class="function"><span class="title">fullName3</span>(<span class="params">state,getters,rootState</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullName2 + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations : &#123;</span><br><span class="line">    <span class="function"><span class="title">nameUpdate</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      state.name = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions : &#123;</span><br><span class="line">    <span class="comment">// context 意为上下文 所以这里指向这个模块</span></span><br><span class="line">    <span class="function"><span class="title">AnameUpdate</span>(<span class="params">context,payload</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(context);</span></span><br><span class="line">        context.commit(<span class="string">&quot;nameUpdate&quot;</span>, payload)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state : &#123;</span><br><span class="line">    count : <span class="number">100</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  modules : &#123;</span><br><span class="line">    ModuleA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul><li>当我们Vuex帮助我们管理过多内容的时候, 会发现index.js文件变得很乱, 我们要将index.js文件解构, 让我们的代码更加清晰</li><li>以下操作都在store文件夹中进行<ul><li>创建getters.js文件, 将index.js中的getters对象抽取到这个文件中</li><li>创建mutations.js文件, 将index.js中的mutations对象抽取到这个文件中</li><li>创建actions.js文件, 将index.js中的actions对象抽取到这个文件中</li><li>创建modules文件夹, 里面创建ModuleA.js文件, 将ModuleA模块抽取到这个文件中</li></ul></li><li>这样我们的代码就变得很清晰了, 方便后期的维护和更新</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是vuex&quot;&gt;&lt;a href=&quot;#什么是vuex&quot; class=&quot;headerlink&quot; title=&quot;什么是vuex&quot;&gt;&lt;/a&gt;什么是vuex&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;官方解释: Vuex是一个专门为Vue.js 应用程序开发的状态管理模式&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="VUE" scheme="http://coderbxd.top/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>15-tabBar组件的开发</title>
    <link href="http://coderbxd.top/2021/06/19/16-Vue-tabbar%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/"/>
    <id>http://coderbxd.top/2021/06/19/16-Vue-tabbar%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/</id>
    <published>2021-06-19T07:04:16.260Z</published>
    <updated>2021-07-02T06:24:06.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="页面下方有一个单独的TabBar组件-如何封装"><a href="#页面下方有一个单独的TabBar组件-如何封装" class="headerlink" title="页面下方有一个单独的TabBar组件, 如何封装"></a>页面下方有一个单独的TabBar组件, 如何封装</h3><ul><li>自定义TabBar组件, 在App组件中使用</li><li>让TabBar处在底部, 并且在 .vue文件中的style标签中设置相关的样式</li></ul><h3 id="页面中会有很多公共的样式-我们如何处理公共样式呢"><a href="#页面中会有很多公共的样式-我们如何处理公共样式呢" class="headerlink" title="页面中会有很多公共的样式, 我们如何处理公共样式呢?"></a>页面中会有很多公共的样式, 我们如何处理公共样式呢?</h3><ul><li>在项目的assets文件夹中创建一个名为css的文件夹, 在该文件夹中创建一个名为 base.css 的文件</li><li>在base.css文件中写入公共的样式</li><li>在 .vue组件文件中的 style标签中使用 @import url 来引入公共的样式</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个是 .vue组件中的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/* 在style标签中使用@import url 来引入样式 */</span></span></span><br><span class="line"><span class="css"><span class="keyword">@import</span> <span class="string">&quot;./assets/css/base.css&quot;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="为了组件的可复用性-所以要将组件尽可能地分离"><a href="#为了组件的可复用性-所以要将组件尽可能地分离" class="headerlink" title="为了组件的可复用性, 所以要将组件尽可能地分离"></a>为了组件的可复用性, 所以要将组件尽可能地分离</h3><ul><li>将上面写好的底部TabBar组件</li><li>从App.vue中抽取出来, 放到components文件夹中新建地tabbar文件夹中新建的TabBar.vue文件中</li><li>再将TabBar.vue中的TabBarItem抽取出来, 放到components/tabbar 中新建的TabBarItem.vue文件中</li></ul><h3 id="TabBar中显示的内容要由外界决定"><a href="#TabBar中显示的内容要由外界决定" class="headerlink" title="TabBar中显示的内容要由外界决定"></a>TabBar中显示的内容要由外界决定</h3><ul><li>所以TabBar.vue要定义插槽</li><li>flex布局平分TabBar</li></ul><h3 id="自定义的TabBarItem-可以传入图片和文字"><a href="#自定义的TabBarItem-可以传入图片和文字" class="headerlink" title="自定义的TabBarItem 可以传入图片和文字"></a>自定义的TabBarItem 可以传入图片和文字</h3><ul><li>所以TabBarItem 要定义两个具名插槽: 一个用于插图片, 一个用于插文字</li><li>给两个插槽外层包装div, 用于设置样式</li><li>最后一层一层地在App.vue 中引用组件并且填充插槽, 实现底部TabBar的效果</li></ul><h2 id="记住一点就很好理解了-slot插槽是让别人来插的"><a href="#记住一点就很好理解了-slot插槽是让别人来插的" class="headerlink" title="记住一点就很好理解了, slot插槽是让别人来插的"></a>记住一点就很好理解了, slot插槽是让别人来插的</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里是TabBar.vue的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;tabbar&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个插槽, 用于在App.vue中填充 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里是TabBarItem.vue的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-item&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义了两个具名插槽, 用于在App.vue中填充 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;item-icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;item-text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- tar-bar标签里面的内容就是用于填充TabBar.vue中的插槽的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tar-bar</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- tar-bar-item标签里面的内容就是用于填充TabBarItem.vue中的插槽的 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tar-bar-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">&quot;item-icon&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./assets/img/tabbar/home.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">&quot;item-text&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tar-bar-item</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">tar-bar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="我们可以看到现在的底部tabbar只有一张图片和一个标题"><a href="#我们可以看到现在的底部tabbar只有一张图片和一个标题" class="headerlink" title="我们可以看到现在的底部tabbar只有一张图片和一个标题"></a>我们可以看到现在的底部tabbar只有一张图片和一个标题</h3><ul><li>我们需要传入高亮的图片, 让活跃的tabbar-item 变高亮</li><li>定义另外一个插槽, 插入active-icon的数据</li><li>定义一个变量, 通过v-show来决定是否显示对应的icon</li><li>注意: 如果使用v-show的话, 要将插槽嵌套在一个div中, 将v-show定义在这个div中, 通过div来决定是否显示插槽<ul><li>因为插槽的本质就是让填充的标签取代</li><li>如果将v-show直接定义在插槽中的话, 填充的标签会将v-show这个属性覆盖, 达不到想要的效果</li><li>所以建议如果要给插槽添加属性的话, 就要用一个div包裹插槽, 将属性定义在div中, 通过div来改变插槽</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是TabBarItem中的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-item&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过用一个div包裹slot插槽的做法来保证, 添加的属性可以生效 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;isActive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;item-icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;!isActive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;item-icon-active&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; active: !isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;item-text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;TabBarItem&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      isActive: <span class="literal">false</span>,</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="TabBar实现路由思路"><a href="#TabBar实现路由思路" class="headerlink" title="TabBar实现路由思路"></a>TabBar实现路由思路</h3><ul><li>安装路由: npm install vue-router –save (运行时依赖安装)</li><li>完成router/index.js 的内容, 创建对应的组件<ul><li>不要将所有的组件都放在components文件夹中哪个, 这个文件夹只用来放置公共的组件</li><li>在项目根目录中创建文件夹 views 这个文件夹就是用来放置各个页面的组件间</li><li>在这个views文件夹中再创建以下文件夹<ul><li>home文件夹</li><li>category文件夹</li><li>cart文件夹</li><li>profile文件夹</li></ul></li><li>这几个文件夹分别放置各自页面中的所有组件, 文件夹中也可以创建其他文件夹</li></ul></li><li>在index.js中编写映射关系</li><li>在main.js中注册router</li><li>在App.vue中加入router-view 组件</li></ul><h3 id="让TabBar中的按钮根据当前活动的路由转换颜色"><a href="#让TabBar中的按钮根据当前活动的路由转换颜色" class="headerlink" title="让TabBar中的按钮根据当前活动的路由转换颜色"></a>让TabBar中的按钮根据当前活动的路由转换颜色</h3><ul><li>点击TabBar的item跳转到对应的路由, 监听item的点击, 通过this.$router.replace() 替换路由路径</li><li>通过this.$route.path.indexOf(this.path) !== -1 来判断当前路由是否为active, 如果是则展示active的icon</li><li>动态计算active的样式<ul><li>封装新的计算属性: this.isActive ? {color: “red”} : {}</li></ul></li></ul><h3 id="给路径起别名"><a href="#给路径起别名" class="headerlink" title="给路径起别名"></a>给路径起别名</h3><ul><li>如果我们的项目文件很多的话, 写路径的时候很不方便</li><li>所以我们可以给一些常用的路径起别名, 方便使用</li><li>来到项目根目录中的 build/webpack.base.config.js 文件</li><li>示例: 看下列代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">    <span class="comment">// 在这里可以给路径起别名</span></span><br><span class="line">    <span class="comment">// 注意: 在vue-cli&gt;=3 中才可以在给路径起别名的时候引用其他的别名, 在vue-cli2 中要写入完整的路径</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: resolve(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">      <span class="string">&#x27;assets&#x27;</span> : resolve(<span class="string">&#x27;src/assets&#x27;</span>),</span><br><span class="line">      <span class="string">&#x27;components&#x27;</span> : resolve(<span class="string">&#x27;src/components&#x27;</span>),</span><br><span class="line">      <span class="string">&#x27;views&#x27;</span> : resolve(<span class="string">&#x27;src/views&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>路径别名的使用<ul><li>在JavaScript代码中直接写别名即可</li><li>如果在HTML代码中, 要在别名前加符号 “~” <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在HTML代码中,在别名前加 &quot;~&quot; , 如这个img标签中的src属性所示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">&quot;item-icon&quot;</span> <span class="attr">src</span>=<span class="string">&quot;~assets/img/tabbar/home.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">&quot;item-icon&quot;</span> <span class="attr">src</span>=<span class="string">&quot;~assets/img/tabbar/home_active.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 在JS代码中可以直接使用别名</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> TarBar <span class="keyword">from</span> <span class="string">&quot;components/tabbar/TabBar.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> TarBarItem <span class="keyword">from</span> <span class="string">&quot;components/tabbar/TabBarItem.vue&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;MainTabBar&quot;</span>,</span></span><br><span class="line">  components: &#123; TarBar, TarBarItem &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;页面下方有一个单独的TabBar组件-如何封装&quot;&gt;&lt;a href=&quot;#页面下方有一个单独的TabBar组件-如何封装&quot; class=&quot;headerlink&quot; title=&quot;页面下方有一个单独的TabBar组件, 如何封装&quot;&gt;&lt;/a&gt;页面下方有一个单独的TabBar</summary>
      
    
    
    
    
    <category term="VUE" scheme="http://coderbxd.top/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>14-vue-router路由管理</title>
    <link href="http://coderbxd.top/2021/06/19/15-Vue%20Router%E8%AF%A6%E8%A7%A3/"/>
    <id>http://coderbxd.top/2021/06/19/15-Vue%20Router%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-06-19T07:04:16.254Z</published>
    <updated>2021-07-02T06:24:08.039Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><ul><li>路由是一个网络工程中的一个术语<ul><li>路由(routing) 就是通过互联的网络把信息从源地址传输到目的地址的活动</li></ul></li><li>路由器提供了两种机制: 路由和传送<ul><li>路由是绝对数据包从来源到目的地的路径</li><li>传送将输入端的数据转移到合适的输出段</li></ul></li><li>路由中有一个非常重要的概念叫路由表<ul><li>路由表本质就是一个映射表, 决定了数据包的指向</li></ul></li><li>相关概念<ul><li>内网IP, 每一个链接上网络的设备都有一个内网IP, 这个内网IP是为了区分链接同一个局域网的不同设备, 在同一个局域网中的每个设备的内网IP是唯一的</li><li>公网IP, 公网IP是一个局域网对外链接是用于区分不同局域网的, 每一个局域网的公网IP都是唯一的</li><li>路由中有一个映射表, 将局域网中的内网IP和设备的mac地址对应起来</li></ul></li><li>举个例子<ul><li>现在有一条信息从北京发到广东</li><li>这条信息途中会进过很多路由, 并根据公网IP找到对应的局域网</li><li>再通过路由中的映射表, 找到要传送的设备mac地址对应的内网IP, 再传送给正确的设备</li></ul></li></ul><h3 id="认识web开发的三个阶段"><a href="#认识web开发的三个阶段" class="headerlink" title="认识web开发的三个阶段"></a>认识web开发的三个阶段</h3><h4 id="后端路由阶段"><a href="#后端路由阶段" class="headerlink" title="后端路由阶段"></a>后端路由阶段</h4><ul><li>在早期的网站开发中, 整个HTML页面都是由服务器渲染出来的</li><li>用户在浏览器中输入URL后, 浏览器向服务器发出请求</li><li>服务器直接生产整个渲染好的html页面, 返回给客户端进行展示</li><li>一个网站有那么多个页面, 服务器是怎么处理的呢?<ul><li>一个页面对应一个URL</li><li>URL会发送给服务器, 服务器通过正则对URL进行匹配, 并且最后交给一个Controller进行处理</li><li>Controller进行各种各样的处理后, 将最终生成的HTML页面, 返回给前端</li><li>这就完成了一个IO(input/output)操作</li></ul></li><li>以上的操作就是后端路由(也称为后端渲染)<ul><li>当页面需要请求不同的页面路径内容的时候, 全部交给后端服务器处理, 后端服务器渲染好整个页面后, 将页面返回给客户端</li><li>这种情况下渲染好的页面, 不需要单独加载任何的js和css, 因为在后端服务器已经加载完毕了, 可以直接交给浏览器展示, 这样的操作有利于SEO(搜索优化)</li></ul></li><li>后端路由(后端渲染)的缺点<ul><li>整个页面的模块由后端人员来编写和维护</li><li>前端开发人员如果要开发页面, 需要通过PHP和java等语言来编写页面代码</li><li>而且通常情况下, HTML代码和数据以及它们的对应逻辑会混合在一起, 编写和维护都是非常糟糕的事情</li></ul></li><li>总流程就是, 后端路由就是, 客户端输入URL请求页面, 服务器端接收URL, 服务器端处理URL和页面的映射关系, 服务器端通过java从数据库中读取数据结合html和css加载整个页面, 将整个页面返回给客户端</li></ul><h4 id="前后端分离阶段"><a href="#前后端分离阶段" class="headerlink" title="前后端分离阶段"></a>前后端分离阶段</h4><ul><li>随着Ajax的出现, 就有了前后端分离的开发模式</li><li>前端通过Ajax请求数据, 后端提供API来返回数据, 前端通过JavaScript将返回来的数据渲染到页面中</li><li>这样做的最大优点就是将前后端的责任清晰化, 前端专注于交互和可视化, 后端专注于数据</li><li>并且在移动端(IOS/Android)出现后, 后端不需要再开发其他的接口, 依然使用之前的一套API即可</li><li>目前很多网站都是采用这种开发模式</li><li>总流程是, 前后端分离就是, 客户端输入URL请求页面的时候, 服务器会先从静态资源服务器中返回html+css+js, 然后在前端使用js代码通过Ajax请求API数据, 服务器端再提供API接口服务, 在前端接收到API数据后渲染页面</li><li>大部分代码都是在前端执行并渲染的, 所以叫前端渲染</li></ul><h4 id="单页面富应用-SPA-阶段"><a href="#单页面富应用-SPA-阶段" class="headerlink" title="单页面富应用(SPA)阶段"></a>单页面富应用(SPA)阶段</h4><ul><li>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由</li><li>也就是前端来维护一套路由规则</li><li>静态资源服务器中的html+css+js代码只有一套, 这一套代码包含了很多的组件, 用户在客户端请求页面的时候, 会将这一套代码全部返回给客户端, 用户在该页面请求其他页面的时候, 通过前端路处理URL和页面映射关系, 然后通过Ajax请求API数据, 实现显示不同的组件</li></ul><h4 id="一些概念问题"><a href="#一些概念问题" class="headerlink" title="一些概念问题"></a>一些概念问题</h4><ul><li>如何区分前端渲染和后端渲染<ul><li>前端渲染就是大部分代码都是在前端执行并且渲染</li><li>后端渲染是指客户端请求页面时, 后端服务器渲染整个页面并返回,称为后端渲染</li></ul></li><li>什么是前后端分离<ul><li>前端负责页面交互和可视化, 通过Ajax来请求数据, 后端专注于数据</li></ul></li><li>什么是前端路由,什么是后端路由<ul><li>前端路由是指, 在前端处理URL和页面的映射关系</li><li>后端路由是指, 在客户端发送URL请求后, 在后端服务器处理URL和页面的映射关系</li></ul></li></ul><h3 id="前端路由的核心-改变URL-但是页面不进行整体的刷新"><a href="#前端路由的核心-改变URL-但是页面不进行整体的刷新" class="headerlink" title="前端路由的核心: 改变URL, 但是页面不进行整体的刷新"></a>前端路由的核心: 改变URL, 但是页面不进行整体的刷新</h3><ul><li>通过改变URL的hash值<ul><li>URL的hash也就是锚点(#), 本质是改变window.loaction和href属性</li><li>我们可以通过直接复制loaction.hash来改变href, 但是页面不发生刷新</li></ul></li><li>通过HTML5的history模式: pushState<ul><li>history接口时HTML5新增的, 它有五种模式改变URL而不刷新页面<ul><li>history.pushState(state, title, url), 通过栈结构压入一个新的URL</li><li>history.replaceState(), 修改当前的 history 实体。通过这个接口改变的URL, 不能使用history.back() 后退历史记录</li><li>history.go(num) 前进或者后退指定数量历史记录 num可以时负数, 代表后退</li><li>history.back() 后退, 相当于history.go(-1)</li><li>history.forward() 前进, 相当于history.go(1)</li></ul></li></ul></li></ul><h3 id="vue-router的安装"><a href="#vue-router的安装" class="headerlink" title="vue-router的安装"></a>vue-router的安装</h3><ul><li>我们已经学习过webpack了, 后续开发都是通过工程化的方式进行开发<ul><li>所以在后续, 我们直接使用npm进行安装路由即可</li></ul></li><li>步骤一: 安装路由vue-router (在使用脚手架初始化项目的时候, 会询问是否安装vue-router, 如果安装过了可以在package.json中看到已经有vue-router模块了, 那就不需要再安装了, 如果当时没有安装, 那么现在就可以用npm安装)<ul><li>在当前项目目录下, 命令行输入 npm install vue-router –save(注意时运行时依赖安装)</li></ul></li><li>步骤二: 在模块化工程中使用路由(因为vue-router是一个插件, 所以要通过Vue.use()来安装路由功能)<ul><li>第一步: 在src文件夹中的router文件夹中的index.js文件中(遵循模块化管理代码), 导入vue-router和vue, 并且调用Vue.use()来安装路由功能<ul><li>为什么要使用Vue.ues(), Vue.use() 会去执行插件中的 install方法</li></ul></li><li>第二步: 创建路由实例, 并且编写路由映射配置</li><li>第三步: 在Vue实例中挂载创建的路由实例 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是src/router/index.js 中的代码</span></span><br><span class="line"><span class="comment">// 引入路由需要的相关模块 vue 和 vue-router</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建路由需要三步</span></span><br><span class="line"><span class="comment">// 1. 通过Vue.use() 使用路由</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个路由实例</span></span><br><span class="line"><span class="comment">// 抽离出来的路由与组件的映射关系</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 编写路由与组件的映射关系, 可以将其抽离出去</span></span><br><span class="line">  <span class="comment">// 注意这个option名 必须是routes</span></span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将路由导出, 并在main.js中的Vue实例中挂载创建的路由实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main.js中导入并在Vue实例中挂载创建的路由实例</span></span><br><span class="line"><span class="comment">// 导入router路由</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 挂载路由实例</span></span><br><span class="line">  <span class="comment">// router : router  可以简写成, 对象增强语法</span></span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="vue-router的使用"><a href="#vue-router的使用" class="headerlink" title="vue-router的使用"></a>vue-router的使用</h3><ul><li>第一步: 创建路由组件, 因为路由时一个一个的url和组件的映射关系, 所以先创建好路由组件</li><li>第二步: 配置路由映射, 在router文件夹中的index.js 中配置组件和路径的映射关系</li><li>第三步: 在根组件中, 通过标签 router-link  和  router-view 使用路由<ul><li>router-link&gt;: 这个标签是一个vue-router中内置的组件, 它最终会被渲染成一个 a 标签</li><li>router-view&gt;: 这个标签会根据当前的路径, 动态渲染出不同的组件</li><li>网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等等会和 router-view&gt; 处于同一个等级</li><li>在路由切换的时候, 切换的是 router-view&gt; 中挂载的组件, 其他内容是不会发生改变的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里时在src/components文件夹中的两个子组件</span></span><br><span class="line"><span class="comment">// 这些是Home组件中的代码</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;我是Home内容&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;Home&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&quot;这里是首页&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时About组件的代码</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;我是关于里面的内容&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;About&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&quot;这里是关于&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些是src/router文件夹中的index.js代码</span></span><br><span class="line"><span class="comment">// 引入相关的组件</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&quot;../components/Home.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&quot;../components/About.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是抽离出来的路由与组件的映射关系</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 一条映射信息就是一个对象, 对象中的path和component构成一个映射</span></span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/home&quot;</span>,  <span class="comment">// 用的是path, 而不是url, 因为url是一个完整的地址, 我们只需要修改地址中的一部分, 所以用path</span></span><br><span class="line">    component: Home <span class="comment">// 挂载组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">    component: About</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 在根组件中的template中使用<span class="tag">&lt;<span class="name">router-link</span>&gt;</span> 和 <span class="tag">&lt;<span class="name">router-view</span>&gt;</span> 来使用路由</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> // 这个标签会根据 to属性中的值来修改 url, 此时<span class="tag">&lt;<span class="name">router-view</span>&gt;</span>显示对应的组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>  // 这个标签是用来决定组件显示的位置的</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="路由的默认路径"><a href="#路由的默认路径" class="headerlink" title="路由的默认路径"></a>路由的默认路径</h3><ul><li>在通常情况下, 我们输入网站URL, 进入网站的首页, 我们希望 router-view  直接渲染出首页的内容</li><li>但是现在, 默认是没有显示首页的组件内容的, 而是要用户点击了首页的 router-link 标签才会显示</li><li>那么如何让路径默认跳转到首页, 而且 router-view  渲染首页组件呢?<ul><li>非常简单, 只要在路由配置中多配置一个映射就可以了<ul><li>配置内容为 path: “/“ 这里的意思是, 配置根路径</li><li>redirect : “/name” redirect翻译为重定向, 就是重新定义方向</li></ul></li><li>配置解析<ul><li>在routes中新配置一个映射</li><li>path 配置的是一个根路径 “/“</li><li>redirect是重定向, 表示我们将根路径重新定向到 /home 的路径下,这样我们就可以等我们想要的结果了<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是路由配置的index.js文件</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#123;</span><br><span class="line">    path : <span class="string">&quot;/&quot;</span>, <span class="comment">// 将path配置为根路径</span></span><br><span class="line">    redirect : <span class="string">&quot;/home&quot;</span> <span class="comment">// 重定向, 将根路径重新定向给 /home</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="HTML5的History模式"><a href="#HTML5的History模式" class="headerlink" title="HTML5的History模式"></a>HTML5的History模式</h3><ul><li>通过改变hash值来改变网页的URL, 地址末尾会有一个/# 不好看</li><li>如果通过HTML5的history模式来改变网页的URL, 地址就会好看很多</li><li>只要进行对路由配置文件进行简单的配置即可<ul><li>在路由配置文件中那个的router实例中添加一个option</li><li>mode : “history” 其实这个option值默认是hash, 只是我们手动把它改成history而已</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是路由配置文件 index.js 的代码</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 编写路由与组件的映射关系, 可以将其抽离出去</span></span><br><span class="line">  routes,</span><br><span class="line">  <span class="comment">// 将修改url中的hash值来改变展示的组件, 转换为通过history方法来改变</span></span><br><span class="line">  mode : <span class="string">&quot;history&quot;</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="router-link-标签的补充"><a href="#router-link-标签的补充" class="headerlink" title="router-link 标签的补充"></a>router-link 标签的补充</h3><ul><li>在前面我们只用了 to 这个属性来指定跳转的路径</li><li>router-link 还有一些其他的属性<ul><li>tag : router-link标签默认最终会渲染成 a 标签, 通过tag 属性, 我们可以修改router-link标签最终会渲染成什么标签, 比如设置 tag=”button”, 则该router-link标签最终会被渲染成button标签</li><li>replace : replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个路径, 使用方法: 直接给router-link标签添加replace属性即可, 这个属性没有值</li><li>active-class: 当router-link标签对应的路由匹配成功时, 会自动给当前标签设置了一个router-link-active的class类名, 我们可以通过这个类名修改活动的router-link标签的样式, 设置active-class可以修改这个router-link-active这个默认类名<ul><li>关于router-link-active类, 在进行高亮显示的导航菜单或者底部tabbar时, 会使用这个类</li><li>一般不会修改这个默认的类名, 直接使用默认的router-link-active类名即可</li></ul></li><li>还有另外一种方法改变router-link-active这个默认类名<ul><li>在路由配置文件 index.js中的路由实例对象中添加 linkActiveClass 选项, 值为要修改成的类名, 也可以修改这个默认类名<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    // 通过tag改变最终渲染成的标签</span><br><span class="line">    // 通过replace禁止使用后退功能</span><br><span class="line">    // 通过active-class改变默认的 router-link-active 类名</span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;首页&lt;/router-link&gt;</span></span><br><span class="line"><span class="comment">    &lt;router-link to=&quot;/about&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;关于&lt;/router-link&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="通过代码来实现路由跳转"><a href="#通过代码来实现路由跳转" class="headerlink" title="通过代码来实现路由跳转"></a>通过代码来实现路由跳转</h3><ul><li>有的时候, 页面的跳转可能需要执行对应的JS代码, 这个时候可以使用第二种跳转方式</li><li>本质上为跳转的标签监听事件, 通过methods方法来实现跳转<ul><li>注意不能在方法中通过修改 history.pushState 的值来实现跳转, 这样会跳过了 vue-router 组件</li><li>$route是vue-router 模块给每一个组件构造器添加的</li><li>通过 this.$router.push(“要跳转的路径”) 来实现跳转</li><li>如果想要禁止后退功能, 那么就将push方法改成replace方法即可<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过代码来实现路由跳转 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;homeClick&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;aboutClick&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;App&quot;</span>,</span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="comment">// 通过监听事件来使用 $router 中的方法来实现跳转</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">homeClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这个$router 时vue-router 模块绑定到所有的组件构造器中的</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&quot;/home&quot;);</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果想要做到禁用后退键的效果, 可以使用replace方法</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.replace(<span class="string">&quot;/home&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">aboutClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&quot;/about&quot;);</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.replace(<span class="string">&quot;/about&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul><li>在某些情况下, 一个页面的path路径是不确定的, 比如我们进入用户界面的时候, 希望路径是这样的<ul><li>/user/aaa 或者 /user/bbb</li><li>除了前面的/user之外, 后面还跟上了用户的ID</li><li>这种path和component的匹配关系, 我们称为动态路由</li></ul></li><li>如何实现动态路由<ul><li>第一步: 在组件的路由设置中path, 通过冒号 : 表示后面的路径是不确定的</li><li>第二步: 使用v-bind 绑定根组件的 router-link 中的 to 属性, 使其值 = 确定的路径 + 一个从data传过来的数据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里使路由设置index.js的代码</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#123;</span><br><span class="line">    path : <span class="string">&quot;/user/:userId&quot;</span>,  <span class="comment">// 这里的 /user/ 为确定的路径, :userId 为不确定的路径, 不过要记住冒号后面的名字, 因为可以在组件中获取这个名字 </span></span><br><span class="line">    component : User</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    // 通过v-bind绑定 to 来使to可以使用组件构造器中的数据</span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#x27;/user/&#x27; + Id&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;App&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      Id: <span class="string">&quot;lisi&quot;</span>,  <span class="comment">// 这个Id 模拟从服务器接收的数据</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="传递活动的路由的数据"><a href="#传递活动的路由的数据" class="headerlink" title="传递活动的路由的数据"></a>传递活动的路由的数据</h3><ul><li>前面讲到vue-router 有一个 $router 对象, 里面有方法可以实现路径的跳转</li><li>vue-router 中还有一个对象, 为 $route , 这个对象获取的是页面中当前活跃的路由</li><li>$route是一个路由对象 (route object) 表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息，还有 URL 匹配到的路由记录 (route records)。</li><li>这个对象有很多属性, 可以查看 vue-router 的官方文档</li><li>$route.params 这个属性是一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; userId &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;User&quot;</span>,</span></span><br><span class="line">  computed: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">userId</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// $route对象, 是页面中当前活跃的路由</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 通过params获取路由中的path 中对应的字符串</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">this</span>.$route.params.userId;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="vue打包文件解析"><a href="#vue打包文件解析" class="headerlink" title="vue打包文件解析"></a>vue打包文件解析</h3><ul><li>命令行输入 npm run build 后, 就会对项目进行打包<ul><li>打包完成后项目中会生成一个新的文件夹名叫 dist</li></ul></li><li>dist文件夹解析<ul><li>static文件夹: 里面包含两个文件夹, css文件夹 和 js文件夹<ul><li>css文件夹: 里面存放的是我们的css代码</li><li>js文件夹: 里面存放的是我们的js代码<ul><li>app.xxxx.js文件: 存放的是我们的业务代码, 也就是我们自己写的代码</li><li>manifest.xxxxx.js文件: 存放的是底层支撑的代码, 比如说, 支撑模块和模块之间的导入导出等等</li><li>vendor.xxxxx.js文件: 存放的是提供商也就是第三方的代码, 比如, vue的代码, vue-router的代码等等</li></ul></li></ul></li><li>index.html文件: 入口HTML文件</li></ul></li></ul><h3 id="认识路由的懒加载"><a href="#认识路由的懒加载" class="headerlink" title="认识路由的懒加载"></a>认识路由的懒加载</h3><ul><li>官方解释<ul><li>在打包构建应用的时候, JavaScript 文件会变得非常大, 会影响页面的加载</li><li>如果我们能把不同路由对应的组件分割成不同的代码块, 然后当路由被访问的时候才加载对应组件, 这样就更加高效了</li></ul></li><li>通俗地说<ul><li>首先, 我们知道路由中通常会定义很多不同的页面</li><li>但是这些页面最后都被打包到一个js文件中</li><li>那么多的页面全放在一个js文件中, 这个页面必然会很大</li><li>如果我们一次性从服务器请求下这个页面, 可能会花费一定的事件, 甚至用户的电脑上还出现了短暂空白的情况</li><li>要避免这种情况, 就要使用路由懒加载</li></ul></li><li>路由懒加载做了什么<ul><li>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块, 一个组件打包成一个js文件</li><li>在当这个路由被访问到的时候, 才加载对应的组件</li></ul></li></ul><h3 id="懒加载的方式"><a href="#懒加载的方式" class="headerlink" title="懒加载的方式"></a>懒加载的方式</h3><ul><li>每种方式的使用方法都是改变路由配置 index.js 文件中的导入组件的方式来达到懒加载</li><li>方式一: 结合Vue的异步组件和webpack的代码分析 (这种方式已经很古老了, 不用了嗷)<ul><li>const Home = resolve =&gt; { require.ensure([‘../components/Home.vue’], () =&gt; { resolve(require(‘../components/Home.vue’)) })};</li></ul></li><li>方式二: AMD写法 (比方式一好一点)<ul><li>const Home = resolve =&gt; require([‘../components/Home.vue’], resolve);</li></ul></li><li>方式三: 在ES6中, 我们有更加简单的写法来组织Vue异步组件和Webpack的代码分割 (代码简洁, 推荐)<ul><li>const Home = () =&gt; import(“../components/Home.vue”)</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是路由配置 index.js 文件中的代码</span></span><br><span class="line"><span class="comment">// 引入相关的组件</span></span><br><span class="line"><span class="comment">/* import Home from &quot;../components/Home&quot;;</span></span><br><span class="line"><span class="comment">import About from &quot;../components/About&quot;;</span></span><br><span class="line"><span class="comment">import User from &quot;../components/User&quot;; */</span>  <span class="comment">// 不用这里的引入方法了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用懒加载来引入相关组件</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../components/Home&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> About = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../components/About&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> User = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../components/User&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><ul><li>嵌套路由是一个很常见的功能<ul><li>比如在home页面中, 我们希望通过 /home/news 和 /home/message 访问一些内容</li><li>一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件</li></ul></li><li>实现嵌套路由有两个步骤<ul><li>第一步: 创建对应的子组件, 并在路由映射中配置对应的子路由<ul><li>注意!!! 嵌套的子路由path的路径前不能加 /</li></ul></li><li>第二步: 在组件内部使用 router-view 标签</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 这里是创建的两个子组件</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in news&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;HomeNews&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      news: [<span class="string">&quot;新闻1&quot;</span>, <span class="string">&quot;新闻2&quot;</span>, <span class="string">&quot;新闻3&quot;</span>, <span class="string">&quot;新闻4&quot;</span>],</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in messages&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;HomeMessage&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      messages: [<span class="string">&quot;消息1&quot;</span>, <span class="string">&quot;消息2&quot;</span>, <span class="string">&quot;消息3&quot;</span>, <span class="string">&quot;消息4&quot;</span>],</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是路由配置 index.js 文件</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/home&quot;</span>,  <span class="comment">// 用的是path, 而不是url, 因为url是一个完整的地址, 我们只需要修改地址中的一部分, 所以用path</span></span><br><span class="line">    component: Home, <span class="comment">// 挂载组件</span></span><br><span class="line">    <span class="comment">// 在路由的内部添加children 的option来定义子路由, 数组类型</span></span><br><span class="line">    children : [</span><br><span class="line">      &#123;</span><br><span class="line">        path : <span class="string">&quot;&quot;</span>,</span><br><span class="line">        redirect : <span class="string">&quot;news&quot;</span> <span class="comment">// 设置默认路由</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path : <span class="string">&quot;news&quot;</span>,  <span class="comment">// 注意嵌套在路由里面的路由路径前面不能加 /</span></span><br><span class="line">        component : HomeNews</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path : <span class="string">&quot;message&quot;</span>,</span><br><span class="line">        component : HomeMessage</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h3><ul><li>一般来说一个URL长这样: scheme://host.domain:port/path?query#fragment<ul><li>scheme: 协议</li><li>host: 主机</li><li>domain: 域名</li><li>port: 端口号</li><li>path: 路径</li><li>query: 查询</li><li>fragment: 片段, hash</li></ul></li></ul><h3 id="传递参数的方式"><a href="#传递参数的方式" class="headerlink" title="传递参数的方式"></a>传递参数的方式</h3><ul><li>传递参数主要有两种类型: params 和 query</li><li>params的类型<ul><li>配置路由格式: /router/:id</li><li>传递的方式: 在path后面跟上对应的值</li><li>传递后形成的路径: /router/123, /router/abc</li><li>前面标题为 传递活动的路由的数据 有详细用法</li></ul></li><li>query的类型<ul><li>配置路由格式: /router, 也就是普通配置</li><li>传递的方式: 对象中使用query的key作为传递方式</li><li>传递后形成的路径: /router?id=123, /router?id=abc</li><li>具体操作<ul><li>第一步, 用v-bind为想要传递的router-link标签的 to 属性进行属性绑定, 值为一个对象, 对象中有两个属性, 第一个是path, 值为要传递的路由路径, 第二个为query, 值为一个对象, 里面为要传递的数据</li><li>第二步, 在对应的子组件中, 在组件构造器中computed中使用 $route.query 来接收传递过来的数据,</li><li>第三步, 处理数据, 使用数据</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一步 这里是根组件的代码</span><br><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;&#x2F;profile&#39;, query: &#123; name: &#39;xiaoLam&#39;, age: 18, height: 1.7 &#125;&#125;&quot; tag&#x3D;&quot;button&quot;&gt;档案&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是Profile组件&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;我是Profile里的信息&lt;/p&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      <span class="comment">// 使用数据</span></span><br><span class="line">      &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;(item, key) in userData&quot;</span>&gt;&#123;&#123; key &#125;&#125; : &#123;&#123; item &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;Profile&quot;</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">userData</span>(<span class="params"></span>)</span> &#123;  <span class="comment">// 接收传递过来的数据</span></span><br><span class="line">      <span class="comment">// 这里的$route对象是Vue中prototype中的对象, 这个对象是当前活跃的路由组件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$route.query;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和 $router 的区别"></a>$route 和 $router 的区别</h3><ul><li>$router本质是VueRouter实例, 就是一个对象包含所有的路由, 想要导航到不同的URL, 则使用 $router.push() 方法</li><li>$route为当前活跃的路由组件对象</li></ul><h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h3><ul><li>为什么我们可以在各个组件中使用 $router 和 $route?<ul><li>是因为所有组件都是来自, Vue类的原型prototype</li><li>而Vue类的原型prototype中就定义了, $router 和 $route, 而且通过一些方法将所有的路由赋值给了$router, 将当前活跃的路由组件赋值给了$route</li><li>所以我们可以在组件中使用这两个属性</li></ul></li><li>为什么我们可以在组件模板中中使用  router-link  和  router-view  这两个标签<ul><li>是因为Vue在全局中注册了这两个组件</li></ul></li></ul><h3 id="为什么要使用导航守卫"><a href="#为什么要使用导航守卫" class="headerlink" title="为什么要使用导航守卫"></a>为什么要使用导航守卫</h3><ul><li>需求, 在一个SPA应用中, 如何修改网页的标题呢?<ul><li>网页标题是通过 title 标签来现实的, 但是SPA只有一个固定的HTML, 切换不同的页面的时候, 标题并不会改变</li><li>但是我们可以通过JavaScript中 document.title来修改 title 中的内容 window.document.title = “新的标题” (window可以省略)</li><li>那么在Vue项目中, 在哪里修改? 什么时候修改比较合适呢?</li></ul></li><li>普通的修改方式<ul><li>很容易想到的修改标题的位置是每一个路由对应的组件.vue文件中</li><li>通过生命周期函数, 执行对应的代码来修改即可</li><li>但是当页面较多的时候, 这种方式不容易维护(因为要在多个页面执行类似的代码)</li></ul></li><li>使用导航守卫<ul><li>什么是导航守卫<ul><li>vue-router 提供的导航守卫主要用来监听路由的进入和离开的<ul><li>beforEach 守卫函数, 会在路由即将改变前触发, 这个守卫函数需要传入一个函数作为参数<ul><li>这个传入的函数包含三个参数, to, from, next</li><li>to : 即将要进入的目标的路由对象</li><li>from : 当前导航即将要离开的路由对象</li><li>next : 调用了该方法后, 才能进入下一个钩子, 前置守卫函数必须调用这个方法</li></ul></li><li>afterEach 守卫函数, 会在路由改变后触发, 这个守卫函数也需要传入一个函数作为参数<ul><li>这个传入的函数包含两个参数, to , from</li><li>这两个参数的含义与beforEach中的函数的参数含义相同</li><li>后置守卫函数不需要调用next</li></ul></li></ul></li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 普通的修改方式</span><br><span class="line">// 这里是vue组件中的代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;Home&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      message: <span class="string">&quot;这里是首页&quot;</span>,</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="comment">// 我们可以通过Vue的生命周期函数来修改 document.title</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 生命周期函数有很多，这里只使用了created函数， 其会在为路由创建的时候调用</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 但是这样的做的话, 每一个组件都需要添加一个created生命周期函数, 代码重复度很高, 所以我们可以通过在路由配置index.js文件中通过导航守卫, 来修改document.title</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.title = <span class="string">&quot;首页&quot;</span>;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导航守卫写法</span></span><br><span class="line"><span class="comment">// 通过 路由实例中的 beforeEach 方法来监听路由即将改变前事件</span></span><br><span class="line"><span class="comment">// 这个方法需要传入一个参数, 这个参数是一个函数</span></span><br><span class="line"><span class="comment">// 这个函数包含三个参数, 第一个参数为to, 第二个参数为from, 第三个参数为next(其本质是一个函数)</span></span><br><span class="line"><span class="comment">// to指要跳转到的路由, from指从哪个路由跳转, next指进行下一步操作, [注]必须调用next函数,进行下一步,否则路由不会跳转了</span></span><br><span class="line"><span class="comment">// to和from都是是一个路由对象里面包含整个路由的所有信息, 包括其父路由</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果存在路由嵌套的话, 直接用meta是拿不到元数据的</span></span><br><span class="line">  <span class="comment">// 要通过to对象中的metched数组中下标为0的数据中的meta对象来获取预先在路由中设置的元数据</span></span><br><span class="line">  <span class="comment">// meta翻译为元数据（描述数据的数据</span></span><br><span class="line">  <span class="built_in">document</span>.title = to.matched[<span class="number">0</span>].meta.title;</span><br><span class="line">  next(); <span class="comment">// 调用next函数进行下一步</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="导航守卫补充"><a href="#导航守卫补充" class="headerlink" title="导航守卫补充"></a>导航守卫补充</h3><ul><li>补充一: 上面已经提到了, 后置守卫函数afterEach 是不需要主动调用next()函数的</li><li>补充二: next()函数里面也是可以传入参数的, 具体可以浏览 vue-router 的官网</li><li>补充三: 上面所说的两个导航守卫都是全局守卫<ul><li>导航守卫还有路由独享的守卫和组件内守卫</li></ul></li></ul><h3 id="keep-alive组件"><a href="#keep-alive组件" class="headerlink" title="keep-alive组件"></a>keep-alive组件</h3><ul><li>keep-alive是Vue内置的一个组件, 可以使被包含的组件保留状态, 或者避免重新渲染<ul><li>keep-alive组件有两个生命周期钩子函数<ul><li>activated(), 这个函数会在组件进入活跃的时候调用</li><li>deactivated(), 这个函数会在组件离开活跃之前的时候调用</li><li>注意, 这两个函数只能在存在keep-alive组件的情况下使用</li></ul></li></ul></li></ul><h3 id="如何实现切换路由的时候保留组件状态"><a href="#如何实现切换路由的时候保留组件状态" class="headerlink" title="如何实现切换路由的时候保留组件状态"></a>如何实现切换路由的时候保留组件状态</h3><ul><li>首先: 如果组件中具有组件嵌套, 而且有自动跳转默认组件的话, 需要在 路由配置 index.js文件中取消自动跳转</li><li>实现思路: 在组件中的data中存储离开路由前的路由路径, 在再次回到该路由的时候再将路由设置为离开路由前的路由路径达到保留组件状态的效果</li><li>具体操作<ul><li>第一步: 在组件的data中存储默认的路由路径</li><li>第二步, 通过keep-alive中的activated() 函数, 在组件进入活跃的时候, 使用 $router.push() 方法, 将路由路径设置为默认路由路径</li><li>第三步, 通过导航守卫中的组件内守卫, beforeRouteLeave(to, from, next){} 将当前路由路径赋值给data中存储的默认路由路径</li><li>这样就可以达到切换路由的时候保留组件状态的效果</li><li>以后会有更好的方法达到这个效果<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由配置文件 index.js 中的代码</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    children : [</span><br><span class="line">      <span class="comment">// 要实现保留组件状态就不能自动跳转, 取消自动跳转</span></span><br><span class="line">      <span class="comment">/* &#123;</span></span><br><span class="line"><span class="comment">        path : &quot;&quot;,</span></span><br><span class="line"><span class="comment">        redirect : &quot;news&quot;</span></span><br><span class="line"><span class="comment">      &#125;, */</span></span><br><span class="line">      &#123;</span><br><span class="line">        path : <span class="string">&quot;news&quot;</span>,  <span class="comment">// 注意嵌套在路由里面的路由路径前面不能加 /</span></span><br><span class="line">        component : HomeNews</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path : <span class="string">&quot;message&quot;</span>,</span><br><span class="line">        component : HomeMessage</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;Home&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      message: <span class="string">&quot;这里是首页&quot;</span>,</span></span><br><span class="line"><span class="javascript">      path: <span class="string">&quot;home/news&quot;</span>, <span class="comment">// 设置路由默认路径</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="comment">// 以下代码是实现如何在切换组件的时候 保留组件状态</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 首先在组件的data中记录当前路由的路径</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 在路由设置文件 index.js文件中取消自动跳转</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 使用keep-alive组件中的 activated() 生命周期钩子函数 在路由创建的时候, 使用 $router.push 方法设置路径</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">activated</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.$router.push(<span class="built_in">this</span>.path); <span class="comment">// 使用$router.push方法设置路径</span></span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="comment">// 使用导航守卫中的组件内守卫, 记录离开当前组件时候的路由路径</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.path = <span class="built_in">this</span>.$route.path; <span class="comment">// 记录离开当前组件时的路由路径</span></span></span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="keep-alive中的两个重要属性"><a href="#keep-alive中的两个重要属性" class="headerlink" title="keep-alive中的两个重要属性"></a>keep-alive中的两个重要属性</h3><ul><li>keep-alive可以使被包含的组件保留状态, 或者避免重新渲染</li><li>但是我们有些组件就是要频繁的销毁和重新创建</li><li>这个时候就可以用到keep-alive标签中的两个重要的属性了<ul><li>include: 值为字符串或者正则表达式, 只有匹配的组件才会被缓存</li><li>exclude: 值为字符串或者正则表达式, 匹配的组件都不会被缓存</li><li>注意, 有关正则表达式的代码都不能随意加括号<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 keep-alive 标签将router-view标签 包起来 就可以让组件不被销毁 也就是保留组件状态 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果某些组件就是需要频繁的销毁和创建, 那么就用到了keep-alive中的exclude属性了 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意与正则表达式相关的代码不能随意加空格 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">&quot;Profile,User&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是路由&quot;&gt;&lt;a href=&quot;#什么是路由&quot; class=&quot;headerlink&quot; title=&quot;什么是路由&quot;&gt;&lt;/a&gt;什么是路由&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;路由是一个网络工程中的一个术语&lt;ul&gt;
&lt;li&gt;路由(routing) 就是通过互联的网络把信息从源地址</summary>
      
    
    
    
    
    <category term="VUE" scheme="http://coderbxd.top/tags/VUE/"/>
    
  </entry>
  
</feed>
